{
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.calculate_qc_metrics.html": {
        "function_name": "scanpy.pp.calculate_qc_metrics(adata, *, expr_type='counts', var_type='genes', qc_vars=(), percent_top=(50, 100, 200, 500), layer=None, use_raw=False, inplace=False, log1p=True, parallel=None)",
        "description": "Calculate quality control metrics.\nCalculates a number of qc metrics for an AnnData object, see section\nReturns for specifics. Largely based on calculateQCMetrics from scater\n[McCarthy17]. Currently is most efficient on a sparse CSR or dense matrix.\nNote that this method can take a while to compile on the first call. That\nresult is then cached to disk to be used later.\nExample\nCalculate qc metrics for visualization.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "expr_type str (default: 'counts')": "Name of kind of values in X.",
            "var_type str (default: 'genes')": "The kind of thing the variables are.",
            "qc_vars Collection[str] (default: ())": "Keys for boolean columns of .var which identify variables you could\nwant to control for (e.g. \u201cERCC\u201d or \u201cmito\u201d).",
            "percent_top Collection[int] | NoneOptional[Collection[int]] (default: (50, 100, 200, 500))": "Which proportions of top genes to cover. If empty or None don\u2019t\ncalculate. Values are considered 1-indexed, percent_top=[50] finds\ncumulative proportion to the 50th most expressed gene.",
            "layer str | NoneOptional[str] (default: None)": "If provided, use adata.layers[layer] for expression values instead\nof adata.X.",
            "use_raw bool (default: False)": "If True, use adata.raw.X for expression values instead of adata.X.",
            "inplace bool (default: False)": "Whether to place calculated metrics in adata\u2019s .obs and .var.",
            "log1p bool (default: True)": "Set to False to skip computing log1p transformed annotations."
        },
        "Return type": "Tuple[DataFrame, DataFrame] | NoneOptional[Tuple[DataFrame, DataFrame]]",
        "Returns": "Depending on inplace returns calculated metrics\n(as DataFrame) or updates adata\u2019s obs and var.\nObservation level metrics include:\n\ntotal_{var_type}_by_{expr_type}E.g. \u201ctotal_genes_by_counts\u201d. Number of genes with positive counts in a cell.\n\ntotal_{expr_type}E.g. \u201ctotal_counts\u201d. Total number of counts for a cell.\n\npct_{expr_type}_in_top_{n}_{var_type} \u2013 for n in percent_topE.g. \u201cpct_counts_in_top_50_genes\u201d. Cumulative percentage of counts\nfor 50 most expressed genes in a cell.\n\ntotal_{expr_type}_{qc_var} \u2013 for qc_var in qc_varsE.g. \u201ctotal_counts_mito\u201d. Total number of counts for variabes in\nqc_vars.\n\npct_{expr_type}_{qc_var} \u2013 for qc_var in qc_varsE.g. \u201cpct_counts_mito\u201d. Proportion of total counts for a cell which\nare mitochondrial.\n\n\nVariable level metrics include:\n\ntotal_{expr_type}E.g. \u201ctotal_counts\u201d. Sum of counts for a gene.\n\nn_genes_by_{expr_type}E.g. \u201cn_genes_by_counts\u201d. The number of genes with at least 1 count in a cell. Calculated for all cells.\n\nmean_{expr_type}E.g. \u201cmean_counts\u201d. Mean expression over all cells.\n\nn_cells_by_{expr_type}E.g. \u201cn_cells_by_counts\u201d. Number of cells this expression is\nmeasured in.\n\npct_dropout_by_{expr_type}E.g. \u201cpct_dropout_by_counts\u201d. Percentage of cells this feature does\nnot appear in.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.filter_cells.html": {
        "function_name": "scanpy.pp.filter_cells(data, min_counts=None, min_genes=None, max_counts=None, max_genes=None, inplace=True, copy=False)",
        "description": "Filter cell outliers based on counts and numbers of genes expressed.\nFor instance, only keep cells with at least min_counts counts or\nmin_genes genes expressed. This is to filter measurement outliers,\ni.e. \u201cunreliable\u201d observations.\nOnly provide one of the optional parameters min_counts, min_genes,\nmax_counts, max_genes per call.\nExamples",
        "Parameters": {
            "data AnnData": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "min_counts int | NoneOptional[int] (default: None)": "Minimum number of counts required for a cell to pass filtering.",
            "min_genes int | NoneOptional[int] (default: None)": "Minimum number of genes expressed required for a cell to pass filtering.",
            "max_counts int | NoneOptional[int] (default: None)": "Maximum number of counts required for a cell to pass filtering.",
            "max_genes int | NoneOptional[int] (default: None)": "Maximum number of genes expressed required for a cell to pass filtering.",
            "inplace bool (default: True)": "Perform computation inplace or return result."
        },
        "Return type": "Tuple[ndarray, ndarray] | NoneOptional[Tuple[ndarray, ndarray]]",
        "Returns": "Depending on inplace, returns the following arrays or directly subsets\nand annotates the data matrix:\n\ncells_subsetndarrayBoolean index mask that does filtering. True means that the\ncell is kept. False means the cell is removed.\n\nnumber_per_cellndarrayDepending on what was thresholded (counts or genes),\nthe array stores n_counts or n_cells per gene.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.filter_genes.html": {
        "function_name": "scanpy.pp.filter_genes(data, min_counts=None, min_cells=None, max_counts=None, max_cells=None, inplace=True, copy=False)",
        "description": "Filter genes based on number of cells or counts.\nKeep genes that have at least min_counts counts or are expressed in at\nleast min_cells cells or have at most max_counts counts or are expressed\nin at most max_cells cells.\nOnly provide one of the optional parameters min_counts, min_cells,\nmax_counts, max_cells per call.",
        "Parameters": {
            "data AnnData": "An annotated data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes.",
            "min_counts int | NoneOptional[int] (default: None)": "Minimum number of counts required for a gene to pass filtering.",
            "min_cells int | NoneOptional[int] (default: None)": "Minimum number of cells expressed required for a gene to pass filtering.",
            "max_counts int | NoneOptional[int] (default: None)": "Maximum number of counts required for a gene to pass filtering.",
            "max_cells int | NoneOptional[int] (default: None)": "Maximum number of cells expressed required for a gene to pass filtering.",
            "inplace bool (default: True)": "Perform computation inplace or return result."
        },
        "Return type": "AnnData | None | Tuple[ndarray, ndarray]Union[AnnData, None, Tuple[ndarray, ndarray]]",
        "Returns": "Depending on inplace, returns the following arrays or directly subsets\nand annotates the data matrix\n\ngene_subsetndarrayBoolean index mask that does filtering. True means that the\ngene is kept. False means the gene is removed.\n\nnumber_per_genendarrayDepending on what was thresholded (counts or cells), the array stores\nn_counts or n_cells per gene.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.highly_variable_genes.html": {
        "function_name": "scanpy.pp.highly_variable_genes(adata, layer=None, n_top_genes=None, min_disp=0.5, max_disp=inf, min_mean=0.0125, max_mean=3, span=0.3, n_bins=20, flavor='seurat', subset=False, inplace=True, batch_key=None, check_values=True)",
        "description": "Annotate highly variable genes [Satija15] [Zheng17] [Stuart19].\nExpects logarithmized data, except when flavor='seurat_v3', in which count\ndata is expected.\nDepending on flavor, this reproduces the R-implementations of Seurat\n[Satija15], Cell Ranger [Zheng17], and Seurat v3 [Stuart19]. Seurat v3 flavor\nrequires scikit-misc package. If you plan to use this flavor, consider\ninstalling scanpy with this optional dependency: scanpy[skmisc].\nFor the dispersion-based methods (flavor='seurat' [Satija15] and\nflavor='cell_ranger' [Zheng17]), the normalized dispersion is obtained\nby scaling with the mean and standard deviation of the dispersions for genes\nfalling into a given bin for mean expression of genes. This means that for each\nbin of mean expression, highly variable genes are selected.\nFor flavor='seurat_v3' [Stuart19], a normalized variance for each gene\nis computed. First, the data are standardized (i.e., z-score normalization\nper feature) with a regularized standard deviation. Next, the normalized variance\nis computed as the variance of each gene after the transformation. Genes are ranked\nby the normalized variance.\nSee also scanpy.experimental.pp._highly_variable_genes for additional flavours\n(e.g. Pearson residuals).\nNotes\nThis function replaces filter_genes_dispersion().",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes.",
            "layer str | NoneOptional[str] (default: None)": "If provided, use adata.layers[layer] for expression values instead of adata.X.",
            "n_top_genes int | NoneOptional[int] (default: None)": "Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3'.",
            "min_mean float | NoneOptional[float] (default: 0.0125)": "If n_top_genes unequals None, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if flavor='seurat_v3'.",
            "max_mean float | NoneOptional[float] (default: 3)": "If n_top_genes unequals None, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if flavor='seurat_v3'.",
            "min_disp float | NoneOptional[float] (default: 0.5)": "If n_top_genes unequals None, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if flavor='seurat_v3'.",
            "max_disp float | NoneOptional[float] (default: inf)": "If n_top_genes unequals None, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if flavor='seurat_v3'.",
            "span float | NoneOptional[float] (default: 0.3)": "The fraction of the data (cells) used when estimating the variance in the loess\nmodel fit if flavor='seurat_v3'.",
            "n_bins int (default: 20)": "Number of bins for binning the mean gene expression. Normalization is\ndone with respect to each bin. If just a single gene falls into a bin,\nthe normalized dispersion is artificially set to 1. You\u2019ll be informed\nabout this if you set settings.verbosity = 4.",
            "flavor {\u2018seurat\u2019, \u2018cell_ranger\u2019, \u2018seurat_v3\u2019}Literal[\u2018seurat\u2019, \u2018cell_ranger\u2019, \u2018seurat_v3\u2019] (default: 'seurat')": "Choose the flavor for identifying highly variable genes. For the dispersion\nbased methods in their default workflows, Seurat passes the cutoffs whereas\nCell Ranger passes n_top_genes.",
            "subset bool (default: False)": "Inplace subset to highly-variable genes if True otherwise merely indicate\nhighly variable genes.",
            "inplace bool (default: True)": "Whether to place calculated metrics in .var or return them.",
            "batch_key str | NoneOptional[str] (default: None)": "If specified, highly-variable genes are selected within each batch separately and merged.\nThis simple process avoids the selection of batch-specific genes and acts as a\nlightweight batch correction method. For all flavors, genes are first sorted\nby how many batches they are a HVG. For dispersion-based flavors ties are broken\nby normalized dispersion. If flavor = 'seurat_v3', ties are broken by the median\n(across batches) rank based on within-batch normalized variance.",
            "check_values bool (default: True)": "Check if counts in selected layer are integers. A Warning is returned if set to True.\nOnly used if flavor='seurat_v3'."
        },
        "Return type": "DataFrame | NoneOptional[DataFrame]",
        "Returns": "Depending on inplace returns calculated metrics (DataFrame) or\nupdates .var with the following fields\n\nhighly_variableboolboolean indicator of highly-variable genes\n\nmeansmeans per gene\n\ndispersionsFor dispersion-based flavors, dispersions per gene\n\ndispersions_normFor dispersion-based flavors, normalized dispersions per gene\n\nvariancesFor flavor='seurat_v3', variance per gene\n\nvariances_normFor flavor='seurat_v3', normalized variance per gene, averaged in\nthe case of multiple batches\n\nhighly_variable_rankfloatFor flavor='seurat_v3', rank of the gene according to normalized\nvariance, median rank in the case of multiple batches\n\nhighly_variable_nbatchesintIf batch_key is given, this denotes in how many batches genes are detected as HVG\n\nhighly_variable_intersectionboolIf batch_key is given, this denotes the genes that are highly variable in all batches\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.log1p.html": {
        "function_name": "scanpy.pp.log1p(X, *, base=None, copy=False, chunked=None, chunk_size=None, layer=None, obsm=None)",
        "description": "Logarithmize the data matrix.\nComputes \\(X = \\log(X + 1)\\),\nwhere \\(log\\) denotes the natural logarithm unless a different base is given.",
        "Parameters": {
            "X AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "base Number | NoneOptional[Number] (default: None)": "Base of the logarithm. Natural logarithm is used by default.",
            "copy bool (default: False)": "If an AnnData is passed, determines whether a copy\nis returned.",
            "chunked bool (default: None)": "Process the data matrix in chunks, which will save memory.\nApplies only to AnnData.",
            "chunk_size int | NoneOptional[int] (default: None)": "n_obs of the chunks to process the data in.",
            "layer str | NoneOptional[str] (default: None)": "Entry of layers to transform.",
            "obsm str | NoneOptional[str] (default: None)": "Entry of obsm to transform."
        },
        "Returns": "Returns or updates data, depending on copy.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.pca.html": {
        "function_name": "scanpy.pp.pca(data, n_comps=None, *, layer=None, zero_center=True, svd_solver=None, random_state=0, return_info=False, use_highly_variable=None, dtype='float32', copy=False, chunked=False, chunk_size=None)",
        "description": "Principal component analysis [Pedregosa11].\nComputes PCA coordinates, loadings and variance decomposition.\nUses the implementation of scikit-learn [Pedregosa11].",
        "Parameters": {
            "data AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "n_comps int | NoneOptional[int] (default: None)": "Number of principal components to compute. Defaults to 50, or 1 - minimum\ndimension size of selected representation.",
            "layer str | NoneOptional[str] (default: None)": "If provided, which element of layers to use for PCA.",
            "zero_center bool | NoneOptional[bool] (default: True)": "If True, compute standard PCA from covariance matrix.\nIf False, omit zero-centering variables\n(uses scikit-learn TruncatedSVD or\ndask-ml TruncatedSVD),\nwhich allows to handle sparse input efficiently.\nPassing None decides automatically based on sparseness of the data.",
            "svd_solver str | NoneOptional[str] (default: None)": "SVD solver to use:\n\nNoneSee chunked and zero_center descriptions to determine which class will be used.\nDepending on the class and the type of X different values for default will be set.\nIf scikit-learn PCA is used, will give 'arpack',\nif scikit-learn TruncatedSVD is used, will give 'randomized',\nif dask-ml PCA or IncrementalPCA is used, will give 'auto',\nif dask-ml TruncatedSVD is used, will give 'tsqr'\n\n'arpack'for the ARPACK wrapper in SciPy (svds())\nNot available with dask arrays.\n\n'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,\nthis will use svd_compressed().\n\n'auto'chooses automatically depending on the size of the problem.\n\n'lobpcg'An alternative SciPy solver. Not available with dask arrays.\n\n'tsqr'Only available with dask arrays. \u201ctsqr\u201d\nalgorithm from Benson et. al. (2013).\n\n\n\nChanged in version 1.9.3: Default value changed from 'arpack' to None.\n\n\nChanged in version 1.4.5: Default value changed from 'auto' to 'arpack'.\n\nEfficient computation of the principal components of a sparse matrix\ncurrently only works with the 'arpack\u2019 or 'lobpcg' solvers.\nIf X is a dask array, dask-ml classes PCA, IncrementalPCA,\nor TruncatedSVD will be used. Otherwise their scikit-learn counterparts PCA, IncrementalPCA, or TruncatedSVD\nwill be used."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.normalize_total.html": {
        "function_name": "scanpy.pp.normalize_total(adata, target_sum=None, exclude_highly_expressed=False, max_fraction=0.05, key_added=None, layer=None, layers=None, layer_norm=None, inplace=True, copy=False)",
        "description": "Normalize counts per cell.\nNormalize each cell by total counts over all genes,\nso that every cell has the same total count after normalization.\nIf choosing target_sum=1e6, this is CPM normalization.\nIf exclude_highly_expressed=True, very highly expressed genes are excluded\nfrom the computation of the normalization factor (size factor) for each\ncell. This is meaningful as these can strongly influence the resulting\nnormalized values for all other genes [Weinreb17].\nSimilar functions are used, for example, by Seurat [Satija15], Cell Ranger\n[Zheng17] or SPRING [Weinreb17].\nExample",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "target_sum float | NoneOptional[float] (default: None)": "If None, after normalization, each observation (cell) has a total\ncount equal to the median of total counts for observations (cells)\nbefore normalization.",
            "exclude_highly_expressed bool (default: False)": "Exclude (very) highly expressed genes for the computation of the\nnormalization factor (size factor) for each cell. A gene is considered\nhighly expressed, if it has more than max_fraction of the total counts\nin at least one cell. The not-excluded genes will sum up to\ntarget_sum.",
            "max_fraction float (default: 0.05)": "If exclude_highly_expressed=True, consider cells as highly expressed\nthat have more counts than max_fraction of the original total counts\nin at least one cell.",
            "key_added str | NoneOptional[str] (default: None)": "Name of the field in adata.obs where the normalization factor is\nstored.",
            "layer str | NoneOptional[str] (default: None)": "Layer to normalize instead of X. If None, X is normalized.",
            "inplace bool (default: True)": "Whether to update adata or return dictionary with normalized copies of\nadata.X and adata.layers.",
            "copy bool (default: False)": "Whether to modify copied input object. Not compatible with inplace=False."
        },
        "Return type": "{str: ndarray} | NoneOptional[Dict[str, ndarray]]",
        "Returns": "Returns dictionary with normalized copies of adata.X and adata.layers\nor updates adata with normalized version of the original\nadata.X and adata.layers, depending on inplace.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.regress_out.html": {
        "function_name": "scanpy.pp.regress_out(adata, keys, layer=None, n_jobs=None, copy=False)",
        "description": "Regress out (mostly) unwanted sources of variation.\nUses simple linear regression. This is inspired by Seurat\u2019s regressOut\nfunction in R [Satija15]. Note that this function tends to overcorrect\nin certain circumstances as described in issue526.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "keys str | Sequence[str]Union[str, Sequence[str]]": "Keys for observation annotation on which to regress on.",
            "layer str | NoneOptional[str] (default: None)": "If provided, which element of layers to regress on.",
            "n_jobs int | NoneOptional[int] (default: None)": "Number of jobs for parallel computation.\nNone means using scanpy._settings.ScanpyConfig.n_jobs.",
            "copy bool (default: False)": "Determines whether a copy of adata is returned."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy returns or updates adata with the corrected data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.scale.html": {
        "function_name": "scanpy.pp.scale(X, zero_center=True, max_value=None, copy=False, layer=None, obsm=None)",
        "description": "Scale data to unit variance and zero mean.",
        "Parameters": {
            "X AnnData | spmatrix | ndarrayUnion[AnnData, spmatrix, ndarray]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "zero_center bool (default: True)": "If False, omit zero-centering variables, which allows to handle sparse\ninput efficiently.",
            "max_value float | NoneOptional[float] (default: None)": "Clip (truncate) to this value after scaling. If None, do not clip.",
            "copy bool (default: False)": "Whether this function should be performed inplace. If an AnnData object\nis passed, this also determines if a copy is returned.",
            "layer str | NoneOptional[str] (default: None)": "If provided, which element of layers to scale.",
            "obsm str | NoneOptional[str] (default: None)": "If provided, which element of obsm to scale."
        },
        "Returns": "Depending on copy returns or updates adata with a scaled adata.X,\nannotated with 'mean' and 'std' in adata.var.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.subsample.html": {
        "function_name": "scanpy.pp.subsample(data, fraction=None, n_obs=None, random_state=0, copy=False)",
        "description": "Subsample to a fraction of the number of observations.",
        "Parameters": {
            "data AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "fraction float | NoneOptional[float] (default: None)": "Subsample to this fraction of the number of observations.",
            "n_obs int | NoneOptional[int] (default: None)": "Subsample to this number of observations.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Random seed to change subsampling.",
            "copy bool (default: False)": "If an AnnData is passed,\ndetermines whether a copy is returned."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Returns X[obs_indices], obs_indices if data is array-like, otherwise\nsubsamples the passed AnnData (copy == False) or\nreturns a subsampled copy of it (copy == True).\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.downsample_counts.html": {
        "function_name": "scanpy.pp.downsample_counts(adata, counts_per_cell=None, total_counts=None, *, random_state=0, replace=False, copy=False)",
        "description": "Downsample counts from count matrix.\nIf counts_per_cell is specified, each cell will downsampled.\nIf total_counts is specified, expression matrix will be downsampled to\ncontain at most total_counts.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "counts_per_cell int | Collection[int] | NoneUnion[int, Collection[int], None] (default: None)": "Target total counts per cell. If a cell has more than \u2018counts_per_cell\u2019,\nit will be downsampled to this number. Resulting counts can be specified\non a per cell basis by passing an array.Should be an integer or integer\nndarray with same length as number of obs.",
            "total_counts int | NoneOptional[int] (default: None)": "Target total counts. If the count matrix has more than total_counts\nit will be downsampled to have this number.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Random seed for subsampling.",
            "replace bool (default: False)": "Whether to sample the counts with replacement.",
            "copy bool (default: False)": "Determines whether a copy of adata is returned."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy returns or updates an adata with downsampled .X.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pp.recipe_zheng17.html": {
        "function_name": "scanpy.pp.recipe_zheng17(adata, n_top_genes=1000, log=True, plot=False, copy=False)",
        "description": "Normalization and filtering as of [Zheng17].\nReproduces the preprocessing of [Zheng17] \u2013 the Cell Ranger R Kit of 10x\nGenomics.\nExpects non-logarithmized data.\nIf using logarithmized data, pass log=False.\nThe recipe runs the following steps",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_top_genes int (default: 1000)": "Number of genes to keep.",
            "log bool (default: True)": "Take logarithm.",
            "plot bool (default: False)": "Show a plot of the gene dispersion vs. mean relation.",
            "copy bool (default: False)": "Return a copy of adata instead of updating it."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Returns or updates adata depending on copy.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pp.recipe_weinreb17.html": {
        "function_name": "scanpy.pp.recipe_weinreb17(adata, log=True, mean_threshold=0.01, cv_threshold=2, n_pcs=50, svd_solver='randomized', random_state=0, copy=False)",
        "description": "Normalization and filtering as of [Weinreb17].\nExpects non-logarithmized data.\nIf using logarithmized data, pass log=False.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "log bool (default: True)": "Logarithmize data?",
            "copy bool (default: False)": "Return a copy if true."
        },
        "Return type": "AnnData | NoneOptional[AnnData]"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pp.recipe_seurat.html": {
        "function_name": "scanpy.pp.recipe_seurat(adata, log=True, plot=False, copy=False)",
        "description": "Normalization and filtering as of Seurat [Satija15].\nThis uses a particular preprocessing.\nExpects non-logarithmized data.\nIf using logarithmized data, pass log=False.",
        "Parameters": {},
        "Return type": "AnnData | NoneOptional[AnnData]"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pp.combat.html": {
        "function_name": "scanpy.pp.combat(adata, key='batch', covariates=None, inplace=True)",
        "description": "ComBat function for batch effect correction [Johnson07] [Leek12]\n[Pedersen12].\nCorrects for batch effects by fitting linear models, gains statistical power\nvia an EB framework where information is borrowed across genes.\nThis uses the implementation combat.py [Pedersen12].",
        "Parameters": {
            "adata AnnData": "Annotated data matrix",
            "key str (default: 'batch')": "Key to a categorical annotation from obs\nthat will be used for batch effect removal.",
            "covariates Collection[str] | NoneOptional[Collection[str]] (default: None)": "Additional covariates besides the batch variable such as adjustment\nvariables or biological condition. This parameter refers to the design\nmatrix X in Equation 2.1 in [Johnson07] and to the mod argument in\nthe original combat function in the sva R package.\nNote that not including covariates may introduce bias or lead to the\nremoval of biological signal in unbalanced designs.",
            "inplace bool (default: True)": "Whether to replace adata.X or to return the corrected data"
        },
        "Return type": "AnnData | ndarray | NoneUnion[AnnData, ndarray, None]",
        "Returns": "Depending on the value of inplace, either returns the corrected matrix or\nor modifies adata.X.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pp.neighbors.html": {
        "function_name": "scanpy.pp.neighbors(adata, n_neighbors=15, n_pcs=None, *, use_rep=None, knn=True, method='umap', transformer=None, metric='euclidean', metric_kwds=mappingproxy({}), random_state=0, key_added=None, copy=False)",
        "description": "Computes the nearest neighbors distance matrix and a neighborhood graph of observations [McInnes18].\nThe neighbor search efficiency of this heavily relies on UMAP [McInnes18],\nwhich also provides a method for estimating connectivities of data points -\nthe connectivity of the manifold (method=='umap'). If method=='gauss',\nconnectivities are computed according to [Coifman05], in the adaption of\n[Haghverdi16].\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_neighbors int (default: 15)": "The size of local neighborhood (in terms of number of neighboring data\npoints) used for manifold approximation. Larger values result in more\nglobal views of the manifold, while smaller values result in more local\ndata being preserved. In general values should be in the range 2 to 100.\nIf knn is True, number of nearest neighbors to be searched. If knn\nis False, a Gaussian kernel width is set to the distance of the\nn_neighbors neighbor.\nignored if ``transformer`` is an instance.",
            "n_pcs int | NoneOptional[int] (default: None)": "Use this many PCs. If n_pcs==0 use .X if use_rep is None.",
            "use_rep str | NoneOptional[str] (default: None)": "Use the indicated representation. 'X' or any key for .obsm is valid.\nIf None, the representation is chosen automatically:\nFor .n_vars < N_PCS (default: 50), .X is used, otherwise \u2018X_pca\u2019 is used.\nIf \u2018X_pca\u2019 is not present, it\u2019s computed with default parameters or n_pcs if present.",
            "knn bool (default: True)": "If True, use a hard threshold to restrict the number of neighbors to\nn_neighbors, that is, consider a knn graph. Otherwise, use a Gaussian\nKernel to assign low weights to neighbors more distant than the\nn_neighbors nearest neighbor.",
            "method {\u2018umap\u2019, \u2018gauss\u2019}Literal[\u2018umap\u2019, \u2018gauss\u2019] (default: 'umap')": "Use \u2018umap\u2019 [McInnes18] or \u2018gauss\u2019 (Gauss kernel following [Coifman05]\nwith adaptive width [Haghverdi16]) for computing connectivities.",
            "transformer KnnTransformerLike | {\u2018pynndescent\u2019, \u2018rapids\u2019} | NoneUnion[KnnTransformerLike, Literal[\u2018pynndescent\u2019, \u2018rapids\u2019], None] (default: None)": "Approximate kNN search implementation following the API of\nKNeighborsTransformer.\nAlso accepts the following known options:\n\nNone (the default)Behavior depends on data size.\nFor small data, we will calculate exact kNN, otherwise we use\nPyNNDescentTransformer\n\n'pynndescent'PyNNDescentTransformer\n\n'rapids'A transformer based on cuml.neighbors.NearestNeighbors.\n\nDeprecated since version 1.10.0: Use rapids_singlecell.pp.neighbors() instead.",
            "metric {\u2018cityblock\u2019, \u2018cosine\u2019, \u2018euclidean\u2019, \u2018l1\u2019, \u2018l2\u2019, \u2018manhattan\u2019} | {\u2018braycurtis\u2019, \u2018canberra\u2019, \u2018chebyshev\u2019, \u2018correlation\u2019, \u2018dice\u2019, \u2018hamming\u2019, \u2018jaccard\u2019, \u2018kulsinski\u2019, \u2018mahalanobis\u2019, \u2018minkowski\u2019, \u2018rogerstanimoto\u2019, \u2018russellrao\u2019, \u2018seuclidean\u2019, \u2018sokalmichener\u2019, \u2018sokalsneath\u2019, \u2018sqeuclidean\u2019, \u2018yule\u2019} | (ndarray, ndarray) \u2192 floatUnion[Literal[\u2018cityblock\u2019, \u2018cosine\u2019, \u2018euclidean\u2019, \u2018l1\u2019, \u2018l2\u2019, \u2018manhattan\u2019], Literal[\u2018braycurtis\u2019, \u2018canberra\u2019, \u2018chebyshev\u2019, \u2018correlation\u2019, \u2018dice\u2019, \u2018hamming\u2019, \u2018jaccard\u2019, \u2018kulsinski\u2019, \u2018mahalanobis\u2019, \u2018minkowski\u2019, \u2018rogerstanimoto\u2019, \u2018russellrao\u2019, \u2018seuclidean\u2019, \u2018sokalmichener\u2019, \u2018sokalsneath\u2019, \u2018sqeuclidean\u2019, \u2018yule\u2019], Callable[[ndarray, ndarray], float]] (default: 'euclidean')": "A known metric\u2019s name or a callable that returns a distance.\nignored if ``transformer`` is an instance.",
            "metric_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Options for the metric.\nignored if ``transformer`` is an instance.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "A numpy random seed.\nignored if ``transformer`` is an instance.",
            "key_added str | NoneOptional[str] (default: None)": "If not specified, the neighbors data is stored in .uns['neighbors'],\ndistances and connectivities are stored in .obsp['distances'] and\n.obsp['connectivities'] respectively.\nIf specified, the neighbors data is added to .uns[key_added],\ndistances are stored in .obsp[key_added+'_distances'] and\nconnectivities in .obsp[key_added+'_connectivities'].",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, updates or returns adata with the following:\nSee key_added parameter description for the storage path of\nconnectivities and distances.\n\nconnectivitiessparse matrix of dtype float32.Weighted adjacency matrix of the neighborhood graph of data\npoints. Weights should be interpreted as connectivities.\n\ndistancessparse matrix of dtype float64.Stores the distance matrix of the nearest neighbors search.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.pca.html": {
        "function_name": "scanpy.tl.pca(data, n_comps=None, *, layer=None, zero_center=True, svd_solver=None, random_state=0, return_info=False, use_highly_variable=None, dtype='float32', copy=False, chunked=False, chunk_size=None)",
        "description": "Principal component analysis [Pedregosa11].\nComputes PCA coordinates, loadings and variance decomposition.\nUses the implementation of scikit-learn [Pedregosa11].",
        "Parameters": {
            "data AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "n_comps int | NoneOptional[int] (default: None)": "Number of principal components to compute. Defaults to 50, or 1 - minimum\ndimension size of selected representation.",
            "layer str | NoneOptional[str] (default: None)": "If provided, which element of layers to use for PCA.",
            "zero_center bool | NoneOptional[bool] (default: True)": "If True, compute standard PCA from covariance matrix.\nIf False, omit zero-centering variables\n(uses scikit-learn TruncatedSVD or\ndask-ml TruncatedSVD),\nwhich allows to handle sparse input efficiently.\nPassing None decides automatically based on sparseness of the data.",
            "svd_solver str | NoneOptional[str] (default: None)": "SVD solver to use:\n\nNoneSee chunked and zero_center descriptions to determine which class will be used.\nDepending on the class and the type of X different values for default will be set.\nIf scikit-learn PCA is used, will give 'arpack',\nif scikit-learn TruncatedSVD is used, will give 'randomized',\nif dask-ml PCA or IncrementalPCA is used, will give 'auto',\nif dask-ml TruncatedSVD is used, will give 'tsqr'\n\n'arpack'for the ARPACK wrapper in SciPy (svds())\nNot available with dask arrays.\n\n'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,\nthis will use svd_compressed().\n\n'auto'chooses automatically depending on the size of the problem.\n\n'lobpcg'An alternative SciPy solver. Not available with dask arrays.\n\n'tsqr'Only available with dask arrays. \u201ctsqr\u201d\nalgorithm from Benson et. al. (2013).\n\n\n\nChanged in version 1.9.3: Default value changed from 'arpack' to None.\n\n\nChanged in version 1.4.5: Default value changed from 'auto' to 'arpack'.\n\nEfficient computation of the principal components of a sparse matrix\ncurrently only works with the 'arpack\u2019 or 'lobpcg' solvers.\nIf X is a dask array, dask-ml classes PCA, IncrementalPCA,\nor TruncatedSVD will be used. Otherwise their scikit-learn counterparts PCA, IncrementalPCA, or TruncatedSVD\nwill be used."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.tsne.html": {
        "function_name": "scanpy.tl.tsne(adata, n_pcs=None, use_rep=None, perplexity=30, early_exaggeration=12, learning_rate=1000, random_state=0, use_fast_tsne=False, n_jobs=None, copy=False, *, metric='euclidean')",
        "description": "t-SNE [Maaten08] [Amir13] [Pedregosa11].\nt-distributed stochastic neighborhood embedding (tSNE) [Maaten08] has been\nproposed for visualizating single-cell data by [Amir13]. Here, by default,\nwe use the implementation of scikit-learn [Pedregosa11]. You can achieve\na huge speedup and better convergence if you install Multicore-tSNE by [Ulyanov16], which\nwill be automatically detected by Scanpy.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_pcs int | NoneOptional[int] (default: None)": "Use this many PCs. If n_pcs==0 use .X if use_rep is None.",
            "use_rep str | NoneOptional[str] (default: None)": "Use the indicated representation. 'X' or any key for .obsm is valid.\nIf None, the representation is chosen automatically:\nFor .n_vars < N_PCS (default: 50), .X is used, otherwise \u2018X_pca\u2019 is used.\nIf \u2018X_pca\u2019 is not present, it\u2019s computed with default parameters or n_pcs if present.",
            "perplexity float | intUnion[float, int] (default: 30)": "The perplexity is related to the number of nearest neighbors that\nis used in other manifold learning algorithms. Larger datasets\nusually require a larger perplexity. Consider selecting a value\nbetween 5 and 50. The choice is not extremely critical since t-SNE\nis quite insensitive to this parameter.",
            "metric str (default: 'euclidean')": "Distance metric calculate neighbors on.",
            "early_exaggeration float | intUnion[float, int] (default: 12)": "Controls how tight natural clusters in the original space are in the\nembedded space and how much space will be between them. For larger\nvalues, the space between natural clusters will be larger in the\nembedded space. Again, the choice of this parameter is not very\ncritical. If the cost function increases during initial optimization,\nthe early exaggeration factor or the learning rate might be too high.",
            "learning_rate float | intUnion[float, int] (default: 1000)": "Note that the R-package \u201cRtsne\u201d uses a default of 200.\nThe learning rate can be a critical parameter. It should be\nbetween 100 and 1000. If the cost function increases during initial\noptimization, the early exaggeration factor or the learning rate\nmight be too high. If the cost function gets stuck in a bad local\nminimum increasing the learning rate helps sometimes.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Change this to use different intial states for the optimization.\nIf None, the initial state is not reproducible.",
            "n_jobs int | NoneOptional[int] (default: None)": "Number of jobs for parallel computation.\nNone means using scanpy._settings.ScanpyConfig.n_jobs.",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nX_tsnenp.ndarray (adata.obsm, dtype float)tSNE coordinates of data.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.umap.html": {
        "function_name": "scanpy.tl.umap(adata, min_dist=0.5, spread=1.0, n_components=2, maxiter=None, alpha=1.0, gamma=1.0, negative_sample_rate=5, init_pos='spectral', random_state=0, a=None, b=None, copy=False, method='umap', neighbors_key=None)",
        "description": "Embed the neighborhood graph using UMAP [McInnes18].\nUMAP (Uniform Manifold Approximation and Projection) is a manifold learning\ntechnique suitable for visualizing high-dimensional data. Besides tending to\nbe faster than tSNE, it optimizes the embedding such that it best reflects\nthe topology of the data, which we represent throughout Scanpy using a\nneighborhood graph. tSNE, by contrast, optimizes the distribution of\nnearest-neighbor distances in the embedding such that these best match the\ndistribution of distances in the high-dimensional space.  We use the\nimplementation of umap-learn\n[McInnes18]. For a few comparisons of UMAP with tSNE, see this preprint.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "min_dist float (default: 0.5)": "The effective minimum distance between embedded points. Smaller values\nwill result in a more clustered/clumped embedding where nearby points on\nthe manifold are drawn closer together, while larger values will result\non a more even dispersal of points. The value should be set relative to\nthe spread value, which determines the scale at which embedded\npoints will be spread out. The default of in the umap-learn package is\n0.1.",
            "spread float (default: 1.0)": "The effective scale of embedded points. In combination with min_dist\nthis determines how clustered/clumped the embedded points are.",
            "n_components int (default: 2)": "The number of dimensions of the embedding.",
            "maxiter int | NoneOptional[int] (default: None)": "The number of iterations (epochs) of the optimization. Called n_epochs\nin the original UMAP.",
            "alpha float (default: 1.0)": "The initial learning rate for the embedding optimization.",
            "gamma float (default: 1.0)": "Weighting applied to negative samples in low dimensional embedding\noptimization. Values higher than one will result in greater weight\nbeing given to negative samples.",
            "negative_sample_rate int (default: 5)": "The number of negative edge/1-simplex samples to use per positive\nedge/1-simplex sample in optimizing the low dimensional embedding.",
            "init_pos {\u2018paga\u2019, \u2018spectral\u2019, \u2018random\u2019} | ndarray | NoneUnion[Literal[\u2018paga\u2019, \u2018spectral\u2019, \u2018random\u2019], ndarray, None] (default: 'spectral')": "How to initialize the low dimensional embedding. Called init in the\noriginal UMAP. Options are:\n\nAny key for adata.obsm.\n\u2019paga\u2019: positions from paga().\n\u2019spectral\u2019: use a spectral embedding of the graph.\n\u2019random\u2019: assign initial embedding positions at random.\nA numpy array of initial embedding positions.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "If int, random_state is the seed used by the random number generator;\nIf RandomState or Generator, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby np.random.",
            "a float | NoneOptional[float] (default: None)": "More specific parameters controlling the embedding. If None these\nvalues are set automatically as determined by min_dist and\nspread.",
            "b float | NoneOptional[float] (default: None)": "More specific parameters controlling the embedding. If None these\nvalues are set automatically as determined by min_dist and\nspread.",
            "copy bool (default: False)": "Return a copy instead of writing to adata.",
            "method {\u2018umap\u2019, \u2018rapids\u2019}Literal[\u2018umap\u2019, \u2018rapids\u2019] (default: 'umap')": "Chosen implementation.\n\n'umap'Umap\u2019s simplical set embedding.\n\n'rapids'GPU accelerated implementation.\n\nDeprecated since version 1.10.0: Use rapids_singlecell.tl.umap() instead.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, umap looks .uns[\u2018neighbors\u2019] for neighbors settings\nand .obsp[\u2018connectivities\u2019] for connectivities\n(default storage places for pp.neighbors).\nIf specified, umap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nX_umapadata.obsm fieldUMAP coordinates of data.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.draw_graph.html": {
        "function_name": "scanpy.tl.draw_graph(adata, layout='fa', init_pos=None, root=None, random_state=0, n_jobs=None, adjacency=None, key_added_ext=None, neighbors_key=None, obsp=None, copy=False, **kwds)",
        "description": "Force-directed graph drawing [Islam11] [Jacomy14] [Chippada18].\nAn alternative to tSNE that often preserves the topology of the data\nbetter. This requires to run neighbors(), first.\nThe default layout (\u2018fa\u2019, ForceAtlas2) [Jacomy14] uses the package fa2\n[Chippada18], which can be installed via pip install fa2.\nForce-directed graph drawing describes a class of long-established\nalgorithms for visualizing graphs.\nIt has been suggested for visualizing single-cell data by [Islam11].\nMany other layouts as implemented in igraph [Csardi06] are available.\nSimilar approaches have been used by [Zunder15] or [Weinreb17].",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "layout {\u2018fr\u2019, \u2018drl\u2019, \u2018kk\u2019, \u2018grid_fr\u2019, \u2018lgl\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018fa\u2019}Literal[\u2018fr\u2019, \u2018drl\u2019, \u2018kk\u2019, \u2018grid_fr\u2019, \u2018lgl\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018fa\u2019] (default: 'fa')": "\u2018fa\u2019 (ForceAtlas2) or any valid igraph layout. Of particular interest\nare \u2018fr\u2019 (Fruchterman Reingold), \u2018grid_fr\u2019 (Grid Fruchterman Reingold,\nfaster than \u2018fr\u2019), \u2018kk\u2019 (Kamadi Kawai\u2019, slower than \u2018fr\u2019), \u2018lgl\u2019 (Large\nGraph, very fast), \u2018drl\u2019 (Distributed Recursive Layout, pretty fast) and\n\u2018rt\u2019 (Reingold Tilford tree layout).",
            "root int | NoneOptional[int] (default: None)": "Root for tree layouts.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "For layouts with random initialization like \u2018fr\u2019, change this to use\ndifferent intial states for the optimization. If None, no seed is set.",
            "adjacency spmatrix | NoneOptional[spmatrix] (default: None)": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
            "key_added_ext str | NoneOptional[str] (default: None)": "By default, append layout.",
            "proceed": "Continue computation, starting off with \u2018X_draw_graph_`layout`\u2019.",
            "init_pos str | bool | NoneUnion[str, bool, None] (default: None)": "'paga'/True, None/False, or any valid 2d-.obsm key.\nUse precomputed coordinates for initialization.\nIf False/None (the default), initialize randomly.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, draw_graph looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, draw_graph looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "obsp str | NoneOptional[str] (default: None)": "Use .obsp[obsp] as adjacency. You can\u2019t specify both\nobsp and neighbors_key at the same time.",
            "copy bool (default: False)": "Return a copy instead of writing to adata.",
            "**kwds": "Parameters of chosen igraph layout. See e.g.\nlayout_fruchterman_reingold() [Fruchterman91].\nOne of the most important ones is maxiter."
        },
        "Returns": "Depending on copy, returns or updates adata with the following field.\n\nX_draw_graph_layoutadata.obsmCoordinates of graph layout. E.g. for layout=\u2019fa\u2019 (the default),\nthe field is called \u2018X_draw_graph_fa\u2019\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.diffmap.html": {
        "function_name": "scanpy.tl.diffmap(adata, n_comps=15, neighbors_key=None, random_state=0, copy=False)",
        "description": "Diffusion Maps [Coifman05] [Haghverdi15] [Wolf18].\nDiffusion maps [Coifman05] has been proposed for visualizing single-cell\ndata by [Haghverdi15]. The tool uses the adapted Gaussian kernel suggested\nby [Haghverdi16] in the implementation of [Wolf18].\nThe width (\u201csigma\u201d) of the connectivity kernel is implicitly determined by\nthe number of neighbors used to compute the single-cell graph in\nneighbors(). To reproduce the original implementation\nusing a Gaussian kernel, use method=='gauss' in\nneighbors(). To use an exponential kernel, use the default\nmethod=='umap'. Differences between these options shouldn\u2019t usually be\ndramatic.\nNotes\nThe 0-th column in adata.obsm[\"X_diffmap\"] is the steady-state solution,\nwhich is non-informative in diffusion maps.\nTherefore, the first diffusion component is at index 1,\ne.g. adata.obsm[\"X_diffmap\"][:,1]",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_comps int (default: 15)": "The number of dimensions of the representation.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, diffmap looks .uns[\u2018neighbors\u2019] for neighbors settings\nand .obsp[\u2018connectivities\u2019], .obsp[\u2018distances\u2019] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, diffmap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]],\n.obsp[.uns[neighbors_key][\u2018distances_key\u2019]] for connectivities and distances\nrespectively.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "A numpy random seed",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nX_diffmapnumpy.ndarray (adata.obsm)Diffusion map representation of data, which is the right eigen basis of\nthe transition matrix with eigenvectors as columns.\n\ndiffmap_evalsnumpy.ndarray (adata.uns)Array of size (number of eigen vectors).\nEigenvalues of transition matrix.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.embedding_density.html": {
        "function_name": "scanpy.tl.embedding_density(adata, basis='umap', groupby=None, key_added=None, components=None)",
        "description": "Calculate the density of cells in an embedding (per condition).\nGaussian kernel density estimation is used to calculate the density of\ncells in an embedded space. This can be performed per category over a\ncategorical cell annotation. The cell density can be plotted using the\npl.embedding_density function.\nNote that density values are scaled to be between 0 and 1. Thus, the\ndensity value at each cell is only comparable to densities in\nthe same category.\nBeware that the KDE estimate used (scipy.stats.gaussian_kde) becomes\nunreliable if you don\u2019t have enough cells in a category.\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.\nExamples",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "basis str (default: 'umap')": "The embedding over which the density will be calculated. This embedded\nrepresentation should be found in adata.obsm['X_[basis]']`.",
            "groupby str | NoneOptional[str] (default: None)": "Key for categorical observation/cell annotation for which densities\nare calculated per category.",
            "key_added str | NoneOptional[str] (default: None)": "Name of the .obs covariate that will be added with the density\nestimates.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The embedding dimensions over which the density should be calculated.\nThis is limited to two components."
        },
        "Return type": "None",
        "Returns": "Updates adata.obs with an additional field specified by the key_added\nparameter. This parameter defaults to [basis]_density_[groupby], where\n[basis] is one of umap, diffmap, pca, tsne, or draw_graph_fa\nand [groupby] denotes the parameter input.\nUpdates adata.uns with an additional field [key_added]_params.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.leiden.html": {
        "function_name": "scanpy.tl.leiden(adata, resolution=1, *, restrict_to=None, random_state=0, key_added='leiden', adjacency=None, directed=True, use_weights=True, n_iterations=- 1, partition_type=None, neighbors_key=None, obsp=None, copy=False, **partition_kwargs)",
        "description": "Cluster cells into subgroups [Traag18].\nCluster cells using the Leiden algorithm [Traag18],\nan improved version of the Louvain algorithm [Blondel08].\nIt has been proposed for single-cell analysis by [Levine15].\nThis requires having ran neighbors() or\nbbknn() first.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "resolution float (default: 1)": "A parameter value controlling the coarseness of the clustering.\nHigher values lead to more clusters.\nSet to None if overriding partition_type\nto one that doesn\u2019t accept a resolution_parameter.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Change the initialization of the optimization.",
            "restrict_to Tuple[str, Sequence[str]] | NoneOptional[Tuple[str, Sequence[str]]] (default: None)": "Restrict the clustering to the categories within the key for sample\nannotation, tuple needs to contain (obs_key, list_of_categories).",
            "key_added str (default: 'leiden')": "adata.obs key under which to add the cluster labels.",
            "adjacency spmatrix | NoneOptional[spmatrix] (default: None)": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
            "directed bool (default: True)": "Whether to treat the graph as directed or undirected.",
            "use_weights bool (default: True)": "If True, edge weights from the graph are used in the computation\n(placing more emphasis on stronger edges).",
            "n_iterations int (default: -1)": "How many iterations of the Leiden clustering algorithm to perform.\nPositive values above 2 define the total number of iterations to perform,\n-1 has the algorithm run until it reaches its optimal clustering.",
            "partition_type Type[MutableVertexPartition] | NoneOptional[Type[MutableVertexPartition]] (default: None)": "Type of partition to use.\nDefaults to RBConfigurationVertexPartition.\nFor the available options, consult the documentation for\nfind_partition().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Use neighbors connectivities as adjacency.\nIf not specified, leiden looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, leiden looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "obsp str | NoneOptional[str] (default: None)": "Use .obsp[obsp] as adjacency. You can\u2019t specify both\nobsp and neighbors_key at the same time.",
            "copy bool (default: False)": "Whether to copy adata or modify it inplace.",
            "**partition_kwargs": "Any further arguments to pass to ~leidenalg.find_partition\n(which in turn passes arguments to the partition_type)."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "\nadata.obs[key_added]Array of dim (number of samples) that stores the subgroup id\n('0', '1', \u2026) for each cell.\n\nadata.uns['leiden']['params']A dict with the values for the parameters resolution, random_state,\nand n_iterations.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.louvain.html": {
        "function_name": "scanpy.tl.louvain(adata, resolution=None, random_state=0, restrict_to=None, key_added='louvain', adjacency=None, flavor='vtraag', directed=True, use_weights=False, partition_type=None, partition_kwargs=mappingproxy({}), neighbors_key=None, obsp=None, copy=False)",
        "description": "Cluster cells into subgroups [Blondel08] [Levine15] [Traag17].\nCluster cells using the Louvain algorithm [Blondel08] in the implementation\nof [Traag17]. The Louvain algorithm has been proposed for single-cell\nanalysis by [Levine15].\nThis requires having ran neighbors() or\nbbknn() first,\nor explicitly passing a adjacency matrix.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "resolution float | NoneOptional[float] (default: None)": "For the default flavor ('vtraag') or for `RAPIDS`, you can provide a\nresolution (higher resolution means finding more and smaller clusters),\nwhich defaults to 1.0.\nSee \u201cTime as a resolution parameter\u201d in [Lambiotte09].",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Change the initialization of the optimization.",
            "restrict_to Tuple[str, Sequence[str]] | NoneOptional[Tuple[str, Sequence[str]]] (default: None)": "Restrict the clustering to the categories within the key for sample\nannotation, tuple needs to contain (obs_key, list_of_categories).",
            "key_added str (default: 'louvain')": "Key under which to add the cluster labels. (default: 'louvain')",
            "adjacency spmatrix | NoneOptional[spmatrix] (default: None)": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
            "flavor {\u2018vtraag\u2019, \u2018igraph\u2019, \u2018rapids\u2019}Literal[\u2018vtraag\u2019, \u2018igraph\u2019, \u2018rapids\u2019] (default: 'vtraag')": "Choose between to packages for computing the clustering.\n\n'vtraag'Much more powerful than 'igraph', and the default.\n\n'igraph'Built in igraph method.\n\n'rapids'GPU accelerated implementation.\n\nDeprecated since version 1.10.0: Use rapids_singlecell.tl.louvain() instead.",
            "directed bool (default: True)": "Interpret the adjacency matrix as directed graph?",
            "use_weights bool (default: False)": "Use weights from knn graph.",
            "partition_type Type[MutableVertexPartition] | NoneOptional[Type[MutableVertexPartition]] (default: None)": "Type of partition to use.\nOnly a valid argument if flavor is 'vtraag'.",
            "partition_kwargs MappingMapping[str, Any] (default: mappingproxy({}))": "Key word arguments to pass to partitioning,\nif vtraag method is being used.",
            "neighbors_key str | NoneOptional[str] (default: None)": "Use neighbors connectivities as adjacency.\nIf not specified, louvain looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, louvain looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "obsp str | NoneOptional[str] (default: None)": "Use .obsp[obsp] as adjacency. You can\u2019t specify both\nobsp and neighbors_key at the same time.",
            "copy bool (default: False)": "Copy adata or modify it inplace."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "\nNoneBy default (copy=False), updates adata with the following fields:\n\nadata.obs['louvain'] (pandas.Series, dtype category)Array of dim (number of samples) that stores the subgroup id\n('0', '1', \u2026) for each cell.\n\n\n\nAnnDataWhen copy=True is set, a copy of adata with those fields is returned.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.dendrogram.html": {
        "function_name": "scanpy.tl.dendrogram(adata, groupby, n_pcs=None, use_rep=None, var_names=None, use_raw=None, cor_method='pearson', linkage_method='complete', optimal_ordering=False, key_added=None, inplace=True)",
        "description": "Computes a hierarchical clustering for the given groupby categories.\nBy default, the PCA representation is used unless .X\nhas less than 50 variables.\nAlternatively, a list of var_names (e.g. genes) can be given.\nAverage values of either var_names or components are used\nto compute a correlation matrix.\nThe hierarchical clustering can be visualized using\nscanpy.pl.dendrogram() or multiple other visualizations that can\ninclude a dendrogram: matrixplot(),\nheatmap(), dotplot(),\nand stacked_violin().\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix",
            "n_pcs int | NoneOptional[int] (default: None)": "Use this many PCs. If n_pcs==0 use .X if use_rep is None.",
            "use_rep str | NoneOptional[str] (default: None)": "Use the indicated representation. 'X' or any key for .obsm is valid.\nIf None, the representation is chosen automatically:\nFor .n_vars < N_PCS (default: 50), .X is used, otherwise \u2018X_pca\u2019 is used.\nIf \u2018X_pca\u2019 is not present, it\u2019s computed with default parameters or n_pcs if present.",
            "var_names Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "List of var_names to use for computing the hierarchical clustering.\nIf var_names is given, then use_rep and n_pcs is ignored.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Only when var_names is not None.\nUse raw attribute of adata if present.",
            "cor_method str (default: 'pearson')": "correlation method to use.\nOptions are \u2018pearson\u2019, \u2018kendall\u2019, and \u2018spearman\u2019",
            "linkage_method str (default: 'complete')": "linkage method to use. See scipy.cluster.hierarchy.linkage()\nfor more information.",
            "optimal_ordering bool (default: False)": "Same as the optimal_ordering argument of scipy.cluster.hierarchy.linkage()\nwhich reorders the linkage matrix so that the distance between successive\nleaves is minimal.",
            "key_added str | NoneOptional[str] (default: None)": "By default, the dendrogram information is added to\n.uns[f'dendrogram_{groupby}'].\nNotice that the groupby information is added to the dendrogram.",
            "inplace bool (default: True)": "If True, adds dendrogram information to adata.uns[key_added],\nelse this function returns the information."
        },
        "Return type": "{str: Any} | NoneOptional[Dict[str, Any]]",
        "Returns": "If inplace=False, returns dendrogram information,\nelse adata.uns[key_added] is updated with it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.dpt.html": {
        "function_name": "scanpy.tl.dpt(adata, n_dcs=10, n_branchings=0, min_group_size=0.01, allow_kendall_tau_shift=True, neighbors_key=None, copy=False)",
        "description": "Infer progression of cells through geodesic distance along the graph\n[Haghverdi16] [Wolf19].\nReconstruct the progression of a biological process from snapshot\ndata. Diffusion Pseudotime has been introduced by [Haghverdi16] and\nimplemented within Scanpy [Wolf18]. Here, we use a further developed\nversion, which is able to deal with disconnected graphs [Wolf19] and can\nbe run in a hierarchical mode by setting the parameter\nn_branchings>1. We recommend, however, to only use\ndpt() for computing pseudotime (n_branchings=0) and\nto detect branchings via paga(). For pseudotime, you need\nto annotate your data with a root cell. For instance:\nThis requires to run neighbors(), first. In order to\nreproduce the original implementation of DPT, use method=='gauss' in\nthis. Using the default method=='umap' only leads to minor quantitative\ndifferences, though.\ndpt() also requires to run\ndiffmap() first. As previously,\ndpt() came with a default parameter of n_dcs=10 but\ndiffmap() has a default parameter of n_comps=15,\nyou need to pass n_comps=10 in diffmap() in order\nto exactly reproduce previous dpt() results.\nNotes\nThe tool is similar to the R package destiny of [Angerer16].",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_dcs int (default: 10)": "The number of diffusion components to use.",
            "n_branchings int (default: 0)": "Number of branchings to detect.",
            "min_group_size float (default: 0.01)": "During recursive splitting of branches (\u2018dpt groups\u2019) for n_branchings\n> 1, do not consider groups that contain less than min_group_size data\npoints. If a float, min_group_size refers to a fraction of the total\nnumber of data points.",
            "allow_kendall_tau_shift bool (default: True)": "If a very small branch is detected upon splitting, shift away from\nmaximum correlation in Kendall tau criterion of [Haghverdi16] to\nstabilize the splitting.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, dpt looks .uns[\u2018neighbors\u2019] for neighbors settings\nand .obsp[\u2018connectivities\u2019], .obsp[\u2018distances\u2019] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, dpt looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]],\n.obsp[.uns[neighbors_key][\u2018distances_key\u2019]] for connectivities and distances\nrespectively.",
            "copy bool (default: False)": "Copy instance before computation and return a copy.\nOtherwise, perform computation inplace and return None."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\nIf n_branchings==0, no field dpt_groups will be written.\n\ndpt_pseudotimepandas.Series (adata.obs, dtype float)Array of dim (number of samples) that stores the pseudotime of each\ncell, that is, the DPT distance with respect to the root cell.\n\ndpt_groupspandas.Series (adata.obs, dtype category)Array of dim (number of samples) that stores the subgroup id (\u20180\u2019,\n\u20181\u2019, \u2026) for each cell. The groups  typically correspond to\n\u2018progenitor cells\u2019, \u2018undecided cells\u2019 or \u2018branches\u2019 of a process.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.paga.html": {
        "function_name": "scanpy.tl.paga(adata, groups=None, use_rna_velocity=False, model='v1.2', neighbors_key=None, copy=False)",
        "description": "Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19].\nBy quantifying the connectivity of partitions (groups, clusters) of the\nsingle-cell graph, partition-based graph abstraction (PAGA) generates a much\nsimpler abstracted graph (PAGA graph) of partitions, in which edge weights\nrepresent confidence in the presence of connections. By thresholding this\nconfidence in paga(), a much simpler representation of the\nmanifold data is obtained, which is nonetheless faithful to the topology of\nthe manifold.\nThe confidence should be interpreted as the ratio of the actual versus the\nexpected value of connections under the null model of randomly connecting\npartitions. We do not provide a p-value as this null model does not\nprecisely capture what one would consider \u201cconnected\u201d in real data, hence it\nstrongly overestimates the expected value. See an extensive discussion of\nthis in [Wolf19].\nNotes\nTogether with a random walk-based distance measure\n(e.g. scanpy.tl.dpt()) this generates a partial coordinatization of\ndata useful for exploring and explaining its variation.",
        "Parameters": {
            "adata AnnData": "An annotated data matrix.",
            "groups str | NoneOptional[str] (default: None)": "Key for categorical in adata.obs. You can pass your predefined groups\nby choosing any categorical annotation of observations. Default:\nThe first present key of 'leiden' or 'louvain'.",
            "use_rna_velocity bool (default: False)": "Use RNA velocity to orient edges in the abstracted graph and estimate\ntransitions. Requires that adata.uns contains a directed single-cell\ngraph with key ['velocity_graph']. This feature might be subject\nto change in the future.",
            "model {\u2018v1.2\u2019, \u2018v1.0\u2019}Literal[\u2018v1.2\u2019, \u2018v1.0\u2019] (default: 'v1.2')": "The PAGA connectivity model.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, paga looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'], .obsp['distances'] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, paga looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']],\n.obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances\nrespectively.",
            "copy bool (default: False)": "Copy adata before computation and return a copy. Otherwise, perform\ncomputation inplace and return None."
        },
        "Returns": "\nconnectivitiesnumpy.ndarray (adata.uns[\u2018connectivities\u2019])The full adjacency matrix of the abstracted graph, weights correspond to\nconfidence in the connectivities of partitions.\n\nconnectivities_treescipy.sparse.csr_matrix (adata.uns[\u2018connectivities_tree\u2019])The adjacency matrix of the tree-like subgraph that best explains\nthe topology.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.ingest.html": {
        "function_name": "scanpy.tl.ingest(adata, adata_ref, obs=None, embedding_method=('umap', 'pca'), labeling_method='knn', neighbors_key=None, inplace=True, **kwargs)",
        "description": "Map labels and embeddings from reference data to new data.\nIntegrating data using ingest and BBKNN\nIntegrates embeddings and annotations of an adata with a reference dataset\nadata_ref through projecting on a PCA (or alternate\nmodel) that has been fitted on the reference data. The function uses a knn\nclassifier for mapping labels and the UMAP package [McInnes18] for mapping\nthe embeddings.\nYou need to run neighbors() on adata_ref before\npassing it.\nExample\nCall sequence:",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes. This is the dataset without labels and\nembeddings.",
            "adata_ref AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes.\nVariables (n_vars and var_names) of adata_ref should be the same\nas in adata.\nThis is the dataset with labels and embeddings\nwhich need to be mapped to adata.",
            "obs str | Iterable[str] | NoneUnion[str, Iterable[str], None] (default: None)": "Labels\u2019 keys in adata_ref.obs which need to be mapped to adata.obs\n(inferred for observation of adata).",
            "embedding_method str | Iterable[str]Union[str, Iterable[str]] (default: ('umap', 'pca'))": "Embeddings in adata_ref which need to be mapped to adata.\nThe only supported values are \u2018umap\u2019 and \u2018pca\u2019.",
            "labeling_method str (default: 'knn')": "The method to map labels in adata_ref.obs to adata.obs.\nThe only supported value is \u2018knn\u2019.",
            "neighbors_key str | NoneOptional[str] (default: None)": "If not specified, ingest looks adata_ref.uns[\u2018neighbors\u2019]\nfor neighbors settings and adata_ref.obsp[\u2018distances\u2019] for\ndistances (default storage places for pp.neighbors).\nIf specified, ingest looks adata_ref.uns[neighbors_key] for\nneighbors settings and\nadata_ref.obsp[adata_ref.uns[neighbors_key][\u2018distances_key\u2019]] for distances.",
            "inplace bool (default: True)": "Only works if return_joint=False.\nAdd labels and embeddings to the passed adata (if True)\nor return a copy of adata with mapped embeddings and labels."
        },
        "Returns": "\nif inplace=False returns a copy of adata\nwith mapped embeddings and labels in obsm and obs correspondingly\nif inplace=True returns None and updates adata.obsm and adata.obs\nwith mapped embeddings and labels\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.rank_genes_groups.html": {
        "function_name": "scanpy.tl.rank_genes_groups(adata, groupby, use_raw=None, groups='all', reference='rest', n_genes=None, rankby_abs=False, pts=False, key_added=None, copy=False, method=None, corr_method='benjamini-hochberg', tie_correct=False, layer=None, **kwds)",
        "description": "Rank genes for characterizing groups.\nExpects logarithmized data.\nNotes\nThere are slight inconsistencies depending on whether sparse\nor dense data are passed. See here.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groupby str": "The key of the observations grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "layer str | NoneOptional[str] (default: None)": "Key from adata.layers whose value will be used to perform tests on.",
            "groups {\u2018all\u2019} | Iterable[str]Union[Literal[\u2018all\u2019], Iterable[str]] (default: 'all')": "Subset of groups, e.g. ['g1', 'g2', 'g3'], to which comparison\nshall be restricted, or 'all' (default), for all groups. Note that if\nreference='rest' all groups will still be used as the reference, not\njust those specified in groups.",
            "reference str (default: 'rest')": "If 'rest', compare each group to the union of the rest of the group.\nIf a group identifier, compare with respect to this group.",
            "n_genes int | NoneOptional[int] (default: None)": "The number of genes that appear in the returned tables.\nDefaults to all genes.",
            "method {\u2018logreg\u2019, \u2018t-test\u2019, \u2018wilcoxon\u2019, \u2018t-test_overestim_var\u2019} | NoneOptional[Literal[\u2018logreg\u2019, \u2018t-test\u2019, \u2018wilcoxon\u2019, \u2018t-test_overestim_var\u2019]] (default: None)": "The default method is 't-test',\n't-test_overestim_var' overestimates variance of each group,\n'wilcoxon' uses Wilcoxon rank-sum,\n'logreg' uses logistic regression. See [Ntranos18],\nhere and here,\nfor why this is meaningful.",
            "corr_method {\u2018benjamini-hochberg\u2019, \u2018bonferroni\u2019}Literal[\u2018benjamini-hochberg\u2019, \u2018bonferroni\u2019] (default: 'benjamini-hochberg')": "p-value correction method.\nUsed only for 't-test', 't-test_overestim_var', and 'wilcoxon'.",
            "tie_correct bool (default: False)": "Use tie correction for 'wilcoxon' scores.\nUsed only for 'wilcoxon'.",
            "rankby_abs bool (default: False)": "Rank genes by the absolute value of the score, not by the\nscore. The returned scores are never the absolute values.",
            "pts bool (default: False)": "Compute the fraction of cells expressing the genes.",
            "key_added str | NoneOptional[str] (default: None)": "The key in adata.uns information is saved to.",
            "**kwds": "Are passed to test methods. Currently this affects only parameters that\nare passed to sklearn.linear_model.LogisticRegression.\nFor instance, you can pass penalty='l1' to try to come up with a\nminimal set of genes that are good predictors (sparse solution meaning\nfew non-zero fitted coefficients)."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "\nnamesstructured np.ndarray (.uns['rank_genes_groups'])Structured array to be indexed by group id storing the gene\nnames. Ordered according to scores.\n\nscoresstructured np.ndarray (.uns['rank_genes_groups'])Structured array to be indexed by group id storing the z-score\nunderlying the computation of a p-value for each gene for each\ngroup. Ordered according to scores.\n\nlogfoldchangesstructured np.ndarray (.uns['rank_genes_groups'])Structured array to be indexed by group id storing the log2\nfold change for each gene for each group. Ordered according to\nscores. Only provided if method is \u2018t-test\u2019 like.\nNote: this is an approximation calculated from mean-log values.\n\npvalsstructured np.ndarray (.uns['rank_genes_groups'])p-values.\n\npvals_adjstructured np.ndarray (.uns['rank_genes_groups'])Corrected p-values.\n\nptspandas.DataFrame (.uns['rank_genes_groups'])Fraction of cells expressing the genes for each group.\n\npts_restpandas.DataFrame (.uns['rank_genes_groups'])Only if reference is set to 'rest'.\nFraction of cells from the union of the rest of each group\nexpressing the genes.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.filter_rank_genes_groups.html": {
        "function_name": "scanpy.tl.filter_rank_genes_groups(adata, key=None, groupby=None, use_raw=None, key_added='rank_genes_groups_filtered', min_in_group_fraction=0.25, min_fold_change=1, max_out_group_fraction=0.5, compare_abs=False)",
        "description": "Filters out genes based on log fold change and fraction of genes expressing the\ngene within and outside the groupby categories.\nSee rank_genes_groups().\nResults are stored in adata.uns[key_added]\n(default: \u2018rank_genes_groups_filtered\u2019).\nTo preserve the original structure of adata.uns[\u2018rank_genes_groups\u2019],\nfiltered genes are set to NaN.\nExamples",
        "Parameters": {
            "adata AnnData": "",
            "key": "",
            "groupby": "",
            "use_raw": "",
            "key_added": "",
            "min_in_group_fraction": "",
            "min_fold_change": "",
            "max_out_group_fraction": "",
            "compare_abs": "If True, compare absolute values of log fold change with min_fold_change."
        },
        "Return type": "None",
        "Returns": "Same output as scanpy.tl.rank_genes_groups() but with filtered genes names set to\nnan\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.marker_gene_overlap.html": {
        "function_name": "scanpy.tl.marker_gene_overlap(adata, reference_markers, *, key='rank_genes_groups', method='overlap_count', normalize=None, top_n_markers=None, adj_pval_threshold=None, key_added='marker_gene_overlap', inplace=False)",
        "description": "Calculate an overlap score between data-deriven marker genes and\nprovided markers\nMarker gene overlap scores can be quoted as overlap counts, overlap\ncoefficients, or jaccard indices. The method returns a pandas dataframe\nwhich can be used to annotate clusters based on marker gene overlaps.\nThis function was written by Malte Luecken.\nExamples",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "reference_markers {str: set} | {str: list}Union[Dict[str, set], Dict[str, list]]": "A marker gene dictionary object. Keys should be strings with the\ncell identity name and values are sets or lists of strings which match\nformat of adata.var_name.",
            "key str (default: 'rank_genes_groups')": "The key in adata.uns where the rank_genes_groups output is stored.\nBy default this is 'rank_genes_groups'.",
            "method {\u2018overlap_count\u2019, \u2018overlap_coef\u2019, \u2018jaccard\u2019}Literal[\u2018overlap_count\u2019, \u2018overlap_coef\u2019, \u2018jaccard\u2019] (default: 'overlap_count')": "(default: overlap_count)\nMethod to calculate marker gene overlap. 'overlap_count' uses the\nintersection of the gene set, 'overlap_coef' uses the overlap\ncoefficient, and 'jaccard' uses the Jaccard index.",
            "normalize {\u2018reference\u2019, \u2018data\u2019} | NoneOptional[Literal[\u2018reference\u2019, \u2018data\u2019]] (default: None)": "Normalization option for the marker gene overlap output. This parameter\ncan only be set when method is set to 'overlap_count'. 'reference'\nnormalizes the data by the total number of marker genes given in the\nreference annotation per group. 'data' normalizes the data by the\ntotal number of marker genes used for each cluster.",
            "top_n_markers int | NoneOptional[int] (default: None)": "The number of top data-derived marker genes to use. By default the top\n100 marker genes are used. If adj_pval_threshold is set along with\ntop_n_markers, then adj_pval_threshold is ignored.",
            "adj_pval_threshold float | NoneOptional[float] (default: None)": "A significance threshold on the adjusted p-values to select marker\ngenes. This can only be used when adjusted p-values are calculated by\nsc.tl.rank_genes_groups(). If adj_pval_threshold is set along with\ntop_n_markers, then adj_pval_threshold is ignored.",
            "key_added str (default: 'marker_gene_overlap')": "Name of the .uns field that will contain the marker overlap scores.",
            "inplace bool (default: False)": "Return a marker gene dataframe or store it inplace in adata.uns."
        },
        "Returns": "A pandas dataframe with the marker gene overlap scores if inplace=False.\nFor inplace=True adata.uns is updated with an additional field\nspecified by the key_added parameter (default = \u2018marker_gene_overlap\u2019).\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.score_genes.html": {
        "function_name": "scanpy.tl.score_genes(adata, gene_list, ctrl_size=50, gene_pool=None, n_bins=25, score_name='score', random_state=0, copy=False, use_raw=None)",
        "description": "Score a set of genes [Satija15].\nThe score is the average expression of a set of genes subtracted with the\naverage expression of a reference set of genes. The reference set is\nrandomly sampled from the gene_pool for each binned expression value.\nThis reproduces the approach in Seurat [Satija15] and has been implemented\nfor Scanpy by Davide Cittaro.\nExamples\nSee this notebook.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "gene_list Sequence[str]": "The list of gene names used for score calculation.",
            "ctrl_size int (default: 50)": "Number of reference genes to be sampled from each bin. If len(gene_list) is not too\nlow, you can set ctrl_size=len(gene_list).",
            "gene_pool Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Genes for sampling the reference set. Default is all genes.",
            "n_bins int (default: 25)": "Number of expression level bins for sampling.",
            "score_name str (default: 'score')": "Name of the field to be added in .obs.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "The random seed for sampling.",
            "copy bool (default: False)": "Copy adata or modify it inplace.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Whether to use raw attribute of adata. Defaults to True if .raw is present.\n\nChanged in version 1.4.5: Default value changed from False to None."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with an additional field\nscore_name.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.score_genes_cell_cycle.html": {
        "function_name": "scanpy.tl.score_genes_cell_cycle(adata, s_genes, g2m_genes, copy=False, **kwargs)",
        "description": "Score cell cycle genes [Satija15].\nGiven two lists of genes associated to S phase and G2M phase, calculates\nscores and assigns a cell cycle phase (G1, S or G2M). See\nscore_genes() for more explanation.\nExamples\nSee this notebook.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "s_genes Sequence[str]": "List of genes associated with S phase.",
            "g2m_genes Sequence[str]": "List of genes associated with G2M phase.",
            "copy bool (default: False)": "Copy adata or modify it inplace.",
            "**kwargs": "Are passed to score_genes(). ctrl_size is not\npossible, as it\u2019s set as min(len(s_genes), len(g2m_genes))."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nS_scoreadata.obs, dtype objectThe score for S phase for each cell.\n\nG2M_scoreadata.obs, dtype objectThe score for G2M phase for each cell.\n\nphaseadata.obs, dtype objectThe cell cycle phase (S, G2M or G1) for each cell.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.sim.html": {
        "function_name": "scanpy.tl.sim(model, params_file=True, tmax=None, branching=None, nrRealizations=None, noiseObs=None, noiseDyn=None, step=None, seed=None, writedir=None)",
        "description": "Simulate dynamic gene expression data [Wittmann09] [Wolf18].\nSample from a stochastic differential equation model built from\nliterature-curated boolean gene regulatory networks, as suggested by\n[Wittmann09]. The Scanpy implementation is due to [Wolf18].\nExamples\nSee this use case",
        "Parameters": {
            "model {\u2018krumsiek11\u2019, \u2018toggleswitch\u2019}Literal[\u2018krumsiek11\u2019, \u2018toggleswitch\u2019]": "Model file in \u2018sim_models\u2019 directory.",
            "params_file bool (default: True)": "Read default params from file.",
            "tmax int | NoneOptional[int] (default: None)": "Number of time steps per realization of time series.",
            "branching bool | NoneOptional[bool] (default: None)": "Only write realizations that contain new branches.",
            "nrRealizations int | NoneOptional[int] (default: None)": "Number of realizations.",
            "noiseObs float | NoneOptional[float] (default: None)": "Observatory/Measurement noise.",
            "noiseDyn float | NoneOptional[float] (default: None)": "Dynamic noise.",
            "step int | NoneOptional[int] (default: None)": "Interval for saving state of system.",
            "seed int | NoneOptional[int] (default: None)": "Seed for generation of random numbers.",
            "writedir str | Path | NoneUnion[str, Path, None] (default: None)": "Path to directory for writing output files."
        },
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.scatter.html": {
        "function_name": "scanpy.pl.scatter(adata, x=None, y=None, color=None, use_raw=None, layers=None, sort_order=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)",
        "description": "Scatter plot along observations or variables axes.\nColor the plot using annotations of observations (.obs), variables\n(.var) or expression of genes (.var_names).",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "x str | NoneOptional[str] (default: None)": "x coordinate.",
            "y str | NoneOptional[str] (default: None)": "y coordinate.",
            "color str | Collection[str]Union[str, Collection[str]] (default: None)": "Keys for annotations of observations/cells or variables/genes,\nor a hex color specification, e.g.,\n'ann1', '#fe57a1', or ['ann1', 'ann2'].",
            "use_raw bool | NoneOptional[bool] (default: None)": "Whether to use raw attribute of adata. Defaults to True if .raw is present.",
            "layers str | Collection[str]Union[str, Collection[str]] (default: None)": "Use the layers attribute of adata if present: specify the layer for\nx, y and color. If layers is a string, then it is expanded to\n(layers, layers, layers).",
            "basis {\u2018pca\u2019, \u2018tsne\u2019, \u2018umap\u2019, \u2018diffmap\u2019, \u2018draw_graph_fr\u2019} | NoneOptional[Literal[\u2018pca\u2019, \u2018tsne\u2019, \u2018umap\u2019, \u2018diffmap\u2019, \u2018draw_graph_fr\u2019]] (default: None)": "String that denotes a plotting tool that computed coordinates.",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | Iterable[str]Union[str, Iterable[str]] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Collection[str]Union[str, Collection[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "legend_loc str (default: 'right margin')": "Location of legend, either 'on data', 'right margin' or a valid keyword\nfor the loc parameter of Legend.",
            "legend_fontsize int | float | {\u2018xx-small\u2019, \u2018x-small\u2019, \u2018small\u2019, \u2018medium\u2019, \u2018large\u2019, \u2018x-large\u2019, \u2018xx-large\u2019} | NoneUnion[int, float, Literal[\u2018xx-small\u2019, \u2018x-small\u2019, \u2018small\u2019, \u2018medium\u2019, \u2018large\u2019, \u2018x-large\u2019, \u2018xx-large\u2019], None] (default: None)": "Numeric size in pt or string describing the size.\nSee set_fontsize().",
            "legend_fontweight int | {\u2018light\u2019, \u2018normal\u2019, \u2018medium\u2019, \u2018semibold\u2019, \u2018bold\u2019, \u2018heavy\u2019, \u2018black\u2019} | NoneUnion[int, Literal[\u2018light\u2019, \u2018normal\u2019, \u2018medium\u2019, \u2018semibold\u2019, \u2018bold\u2019, \u2018heavy\u2019, \u2018black\u2019], None] (default: None)": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.\nSee set_fontweight().",
            "legend_fontoutline float (default: None)": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect withStroke.",
            "colorbar_loc": "Where to place the colorbar for continous variables. If None, no colorbar\nis added.",
            "size int | float | NoneUnion[int, float, None] (default: None)": "Point size. If None, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
            "color_map str | ColormapUnion[str, Colormap] (default: None)": "Color map to use for continous variables. Can be a name or a\nColormap instance (e.g. \"magma\u201d, \"viridis\"\nor mpl.cm.cividis), see get_cmap().\nIf None, the value of mpl.rcParams[\"image.cmap\"] is used.\nThe default color_map can be set using set_figure_params().",
            "palette Cycler | ListedColormap | str | Tuple[float, ...] | Sequence[Union[str, Tuple[float, ...]]]Union[Cycler, ListedColormap, str, Tuple[float, ...], Sequence[Union[str, Tuple[float, ...]]]] (default: None)": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid ListedColormap name\n('Set2', 'tab20', \u2026), a Cycler object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see is_color_like()).\nIf None, mpl.rcParams[\"axes.prop_cycle\"] is used unless the categorical\nvariable already has colors stored in adata.uns[\"{var}_colors\"].\nIf provided, values of adata.uns[\"{var}_colors\"] will be set.",
            "na_color": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if color=None.",
            "na_in_legend": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
            "frameon bool | NoneOptional[bool] (default: None)": "Draw a frame around the scatter plot. Defaults to value set in\nset_figure_params(), defaults to True.",
            "title str | NoneOptional[str] (default: None)": "Provide title for panels either as string or list of strings,\ne.g. ['title1', 'title2', ...].",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.heatmap.html": {
        "function_name": "scanpy.pl.heatmap(adata, var_names, groupby, use_raw=None, log=False, num_categories=7, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, swap_axes=False, show_gene_labels=None, show=None, save=None, figsize=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)",
        "description": "Heatmap of the expression values of genes.\nIf groupby is given, the heatmap is ordered by the respective group. For\nexample, a list of marker genes can be plotted, ordered by clustering. If\nthe groupby observation annotation is not categorical the observation\nannotation is turned into a categorical by binning the data into the number\nspecified in num_categories.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "var_names str | Sequence[str] | MappingUnion[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]": "var_names should be a valid subset of adata.var_names.\nIf var_names is a mapping, then the key is used as label\nto group the values (see var_group_labels). The mapping values\nshould be sequences of valid adata.var_names. In this\ncase either coloring or \u2018brackets\u2019 are used for the grouping\nof var names depending on the plot. When var_names is a mapping,\nthen the var_group_labels and var_group_positions are set.",
            "groupby str | Sequence[str]Union[str, Sequence[str]]": "The key of the observation grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "num_categories int (default: 7)": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
            "categories_order": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "Figure size when multi_panel=True.\nOtherwise the rcParam['figure.figsize] value is used.\nFormat is (width, height)",
            "dendrogram bool | strUnion[bool, str] (default: False)": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the groupby categories is added.\nThe dendrogram information is computed using scanpy.tl.dendrogram().\nIf tl.dendrogram has not been called previously the function is called\nwith default parameters.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols.\nBy default var_names refer to the index column of the .var DataFrame.\nSetting this option allows alternative names to be used.",
            "var_group_positions Sequence[Tuple[int, int]] | NoneOptional[Sequence[Tuple[int, int]]] (default: None)": "Use this parameter to highlight groups of var_names.\nThis will draw a \u2018bracket\u2019 or a color block between the given start and end\npositions. If the parameter var_group_labels is set, the corresponding\nlabels are added on top/left. E.g. var_group_positions=[(4,10)]\nwill add a bracket between the fourth var_name and the tenth var_name.\nBy giving more positions, more brackets/color blocks are drawn.",
            "var_group_labels Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Labels for each of the var_group_positions that want to be highlighted.",
            "var_group_rotation float | NoneOptional[float] (default: None)": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "standard_scale {\u2018var\u2019, \u2018obs\u2019} | NoneOptional[Literal[\u2018var\u2019, \u2018obs\u2019]] (default: None)": "Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,\nsubtract the minimum and divide each by its maximum.",
            "swap_axes bool (default: False)": "By default, the x axis contains var_names (e.g. genes) and the y axis the groupby\ncategories (if any). By setting swap_axes then x are the groupby categories and y the var_names.",
            "show_gene_labels bool | NoneOptional[bool] (default: None)": "By default gene labels are shown when there are 50 or less genes. Otherwise the labels are removed.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "vmin float | NoneOptional[float] (default: None)": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
            "vmax float | NoneOptional[float] (default: None)": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
            "vcenter float | NoneOptional[float] (default: None)": "The value representing the center of the color scale. Useful for diverging colormaps.",
            "norm Normalize | NoneOptional[Normalize] (default: None)": "Custom color normalization object from matplotlib. See\nhttps://matplotlib.org/stable/tutorials/colors/colormapnorms.html for details.",
            "**kwds": "Are passed to matplotlib.pyplot.imshow()."
        },
        "Returns": "List of Axes\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.dotplot.html": {
        "function_name": "scanpy.pl.dotplot(adata, var_names, groupby, use_raw=None, log=False, num_categories=7, expression_cutoff=0.0, mean_only_expressed=False, cmap='Reds', dot_max=None, dot_min=None, standard_scale=None, smallest_dot=0.0, title=None, colorbar_title='Mean expression\\\\nin group', size_title='Fraction of cells\\\\nin group (%)', figsize=None, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, swap_axes=False, dot_color_df=None, show=None, save=None, ax=None, return_fig=False, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)",
        "description": "Makes a dot plot of the expression values of var_names.\nFor each var_name and each groupby category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of cells expressing the var_name in the\ncategory (visualized by the size of the dot). If groupby is not given,\nthe dotplot assumes that all data belongs to a single category.\nAn example of dotplot usage is to visualize, for multiple marker genes,\nthe mean value and the percentage of cells expressing the gene\nacross  multiple clusters.\nThis function provides a convenient interface to the DotPlot\nclass. If you need more flexibility, you should use DotPlot\ndirectly.\nExamples\nCreate a dot plot using the given markers and the PBMC example dataset grouped by\nthe category \u2018bulk_labels\u2019.\nUsing var_names as dict:\nGet DotPlot object for fine tuning\nThe axes used can be obtained using the get_axes() method",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "var_names str | Sequence[str] | MappingUnion[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]": "var_names should be a valid subset of adata.var_names.\nIf var_names is a mapping, then the key is used as label\nto group the values (see var_group_labels). The mapping values\nshould be sequences of valid adata.var_names. In this\ncase either coloring or \u2018brackets\u2019 are used for the grouping\nof var names depending on the plot. When var_names is a mapping,\nthen the var_group_labels and var_group_positions are set.",
            "groupby str | Sequence[str]Union[str, Sequence[str]]": "The key of the observation grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "num_categories int (default: 7)": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
            "categories_order": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "Figure size when multi_panel=True.\nOtherwise the rcParam['figure.figsize] value is used.\nFormat is (width, height)",
            "dendrogram bool | strUnion[bool, str] (default: False)": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the groupby categories is added.\nThe dendrogram information is computed using scanpy.tl.dendrogram().\nIf tl.dendrogram has not been called previously the function is called\nwith default parameters.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols.\nBy default var_names refer to the index column of the .var DataFrame.\nSetting this option allows alternative names to be used.",
            "var_group_positions Sequence[Tuple[int, int]] | NoneOptional[Sequence[Tuple[int, int]]] (default: None)": "Use this parameter to highlight groups of var_names.\nThis will draw a \u2018bracket\u2019 or a color block between the given start and end\npositions. If the parameter var_group_labels is set, the corresponding\nlabels are added on top/left. E.g. var_group_positions=[(4,10)]\nwill add a bracket between the fourth var_name and the tenth var_name.\nBy giving more positions, more brackets/color blocks are drawn.",
            "var_group_labels Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Labels for each of the var_group_positions that want to be highlighted.",
            "var_group_rotation float | NoneOptional[float] (default: None)": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "title str | NoneOptional[str] (default: None)": "Title for the figure",
            "colorbar_title str | NoneOptional[str] (default: 'Mean expression\\\\nin group')": "Title for the color bar. New line character (n) can be used.",
            "cmap str (default: 'Reds')": "String denoting matplotlib color map.",
            "standard_scale {\u2018var\u2019, \u2018group\u2019} | NoneOptional[Literal[\u2018var\u2019, \u2018group\u2019]] (default: None)": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
            "swap_axes bool | NoneOptional[bool] (default: False)": "By default, the x axis contains var_names (e.g. genes) and the y axis\nthe groupby categories. By setting swap_axes then x are the\ngroupby categories and y the var_names.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns DotPlot object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "size_title str | NoneOptional[str] (default: 'Fraction of cells\\\\nin group (%)')": "Title for the size legend. New line character (n) can be used.",
            "expression_cutoff float (default: 0.0)": "Expression cutoff that is used for binarizing the gene expression and\ndetermining the fraction of cells expressing given genes. A gene is\nexpressed only if the expression value is greater than this threshold.",
            "mean_only_expressed bool (default: False)": "If True, gene expression is averaged only over the cells\nexpressing the given genes.",
            "dot_max float | NoneOptional[float] (default: None)": "If none, the maximum dot size is set to the maximum fraction value found\n(e.g. 0.6). If given, the value should be a number between 0 and 1.\nAll fractions larger than dot_max are clipped to this value.",
            "dot_min float | NoneOptional[float] (default: None)": "If none, the minimum dot size is set to 0. If given,\nthe value should be a number between 0 and 1.\nAll fractions smaller than dot_min are clipped to this value.",
            "smallest_dot float | NoneOptional[float] (default: 0.0)": "If none, the smallest dot has size 0.\nAll expression levels with dot_min are plotted with this size.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax _AxesSubplot | NoneOptional[_AxesSubplot] (default: None)": "A matplotlib axes object. Only works if plotting a single component.",
            "vmin float | NoneOptional[float] (default: None)": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
            "vmax float | NoneOptional[float] (default: None)": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
            "vcenter float | NoneOptional[float] (default: None)": "The value representing the center of the color scale. Useful for diverging colormaps.",
            "norm Normalize | NoneOptional[Normalize] (default: None)": "Custom color normalization object from matplotlib. See\nhttps://matplotlib.org/stable/tutorials/colors/colormapnorms.html for details.",
            "kwds": "Are passed to matplotlib.pyplot.scatter()."
        },
        "Return type": "DotPlot | dict | NoneUnion[DotPlot, dict, None]",
        "Returns": "If return_fig is True, returns a DotPlot object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.tracksplot.html": {
        "function_name": "scanpy.pl.tracksplot(adata, var_names, groupby, use_raw=None, log=False, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, layer=None, show=None, save=None, figsize=None, **kwds)",
        "description": "In this type of plot each var_name is plotted as a filled line plot where the\ny values correspond to the var_name values and x is each of the cells. Best results\nare obtained when using raw counts that are not log.\ngroupby is required to sort and order the values using the respective group\nand should be a categorical value.\nExamples\nUsing var_names as list:\nUsing var_names as dict:",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "var_names str | Sequence[str] | MappingUnion[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]": "var_names should be a valid subset of adata.var_names.\nIf var_names is a mapping, then the key is used as label\nto group the values (see var_group_labels). The mapping values\nshould be sequences of valid adata.var_names. In this\ncase either coloring or \u2018brackets\u2019 are used for the grouping\nof var names depending on the plot. When var_names is a mapping,\nthen the var_group_labels and var_group_positions are set.",
            "groupby str | Sequence[str]Union[str, Sequence[str]]": "The key of the observation grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "num_categories": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
            "categories_order": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "Figure size when multi_panel=True.\nOtherwise the rcParam['figure.figsize] value is used.\nFormat is (width, height)",
            "dendrogram bool | strUnion[bool, str] (default: False)": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the groupby categories is added.\nThe dendrogram information is computed using scanpy.tl.dendrogram().\nIf tl.dendrogram has not been called previously the function is called\nwith default parameters.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols.\nBy default var_names refer to the index column of the .var DataFrame.\nSetting this option allows alternative names to be used.",
            "var_group_positions Sequence[Tuple[int, int]] | NoneOptional[Sequence[Tuple[int, int]]] (default: None)": "Use this parameter to highlight groups of var_names.\nThis will draw a \u2018bracket\u2019 or a color block between the given start and end\npositions. If the parameter var_group_labels is set, the corresponding\nlabels are added on top/left. E.g. var_group_positions=[(4,10)]\nwill add a bracket between the fourth var_name and the tenth var_name.\nBy giving more positions, more brackets/color blocks are drawn.",
            "var_group_labels Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Labels for each of the var_group_positions that want to be highlighted.",
            "var_group_rotation": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "**kwds": "Are passed to heatmap()."
        },
        "Returns": "A list of Axes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.violin.html": {
        "function_name": "scanpy.pl.violin(adata, keys, groupby=None, log=False, use_raw=None, stripplot=True, jitter=True, size=1, layer=None, scale='width', order=None, multi_panel=None, xlabel='', ylabel=None, rotation=None, show=None, save=None, ax=None, **kwds)",
        "description": "Violin plot.\nWraps seaborn.violinplot() for AnnData.\nExamples\nPlot by category. Rotate x-axis labels so that they do not overlap.\nSet order of categories to be plotted or select specific categories to be plotted.\nPlot multiple keys.\nFor large datasets consider omitting the overlaid scatter plot.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "keys str | Sequence[str]Union[str, Sequence[str]]": "Keys for accessing variables of .var_names or fields of .obs.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Whether to use raw attribute of adata. Defaults to True if .raw is present.",
            "stripplot bool (default: True)": "Add a stripplot on top of the violin plot.\nSee stripplot().",
            "jitter float | boolUnion[float, bool] (default: True)": "Add jitter to the stripplot (only when stripplot is True)\nSee stripplot().",
            "size int (default: 1)": "Size of the jitter points.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By\ndefault adata.raw.X is plotted. If use_raw=False is set,\nthen adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "scale {\u2018area\u2019, \u2018count\u2019, \u2018width\u2019}Literal[\u2018area\u2019, \u2018count\u2019, \u2018width\u2019] (default: 'width')": "The method used to scale the width of each violin.\nIf \u2018width\u2019 (the default), each violin will have the same width.\nIf \u2018area\u2019, each violin will have the same area.\nIf \u2018count\u2019, a violin\u2019s width corresponds to the number of observations.",
            "order Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Order in which to show the categories.",
            "multi_panel bool | NoneOptional[bool] (default: None)": "Display keys in multiple panels also when groupby is not None.",
            "xlabel str (default: '')": "Label of the x axis. Defaults to groupby if rotation is None,\notherwise, no label is shown.",
            "ylabel str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Label of the y axis. If None and groupby is None, defaults\nto 'value'. If None and groubpy is not None, defaults to keys.",
            "rotation float | NoneOptional[float] (default: None)": "Rotation of xtick labels.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component.",
            "**kwds": "Are passed to violinplot()."
        },
        "Returns": "A Axes object if ax is None else None.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.stacked_violin.html": {
        "function_name": "scanpy.pl.stacked_violin(adata, var_names, groupby, log=False, use_raw=None, num_categories=7, title=None, colorbar_title='Median expression\\\\nin group', figsize=None, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, standard_scale=None, var_group_rotation=None, layer=None, stripplot=False, jitter=False, size=1, scale='width', yticklabels=False, order=None, swap_axes=False, show=None, save=None, return_fig=False, row_palette=None, cmap='Blues', ax=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)",
        "description": "Stacked violin plots.\nMakes a compact image composed of individual violin plots\n(from violinplot()) stacked on top of each other.\nUseful to visualize gene expression per cluster.\nWraps seaborn.violinplot() for AnnData.\nThis function provides a convenient interface to the\nStackedViolin class. If you need more flexibility,\nyou should use StackedViolin directly.\nExamples\nVisualization of violin plots of a few genes grouped by the category bulk_labels:\nSame visualization but passing var_names as dict, which adds a grouping of\nthe genes on top of the image:\nGet StackedViolin object for fine tuning\nThe axes used can be obtained using the get_axes() method:",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "var_names str | Sequence[str] | MappingUnion[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]": "var_names should be a valid subset of adata.var_names.\nIf var_names is a mapping, then the key is used as label\nto group the values (see var_group_labels). The mapping values\nshould be sequences of valid adata.var_names. In this\ncase either coloring or \u2018brackets\u2019 are used for the grouping\nof var names depending on the plot. When var_names is a mapping,\nthen the var_group_labels and var_group_positions are set.",
            "groupby str | Sequence[str]Union[str, Sequence[str]]": "The key of the observation grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "num_categories int (default: 7)": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
            "categories_order": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "Figure size when multi_panel=True.\nOtherwise the rcParam['figure.figsize] value is used.\nFormat is (width, height)",
            "dendrogram bool | strUnion[bool, str] (default: False)": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the groupby categories is added.\nThe dendrogram information is computed using scanpy.tl.dendrogram().\nIf tl.dendrogram has not been called previously the function is called\nwith default parameters.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols.\nBy default var_names refer to the index column of the .var DataFrame.\nSetting this option allows alternative names to be used.",
            "var_group_positions Sequence[Tuple[int, int]] | NoneOptional[Sequence[Tuple[int, int]]] (default: None)": "Use this parameter to highlight groups of var_names.\nThis will draw a \u2018bracket\u2019 or a color block between the given start and end\npositions. If the parameter var_group_labels is set, the corresponding\nlabels are added on top/left. E.g. var_group_positions=[(4,10)]\nwill add a bracket between the fourth var_name and the tenth var_name.\nBy giving more positions, more brackets/color blocks are drawn.",
            "var_group_labels Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Labels for each of the var_group_positions that want to be highlighted.",
            "var_group_rotation float | NoneOptional[float] (default: None)": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "title str | NoneOptional[str] (default: None)": "Title for the figure",
            "colorbar_title str | NoneOptional[str] (default: 'Median expression\\\\nin group')": "Title for the color bar. New line character (n) can be used.",
            "cmap str | NoneOptional[str] (default: 'Blues')": "String denoting matplotlib color map.",
            "standard_scale {\u2018var\u2019, \u2018obs\u2019} | NoneOptional[Literal[\u2018var\u2019, \u2018obs\u2019]] (default: None)": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
            "swap_axes bool (default: False)": "By default, the x axis contains var_names (e.g. genes) and the y axis\nthe groupby categories. By setting swap_axes then x are the\ngroupby categories and y the var_names.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns DotPlot object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "stripplot bool (default: False)": "Add a stripplot on top of the violin plot.\nSee stripplot().",
            "jitter float | boolUnion[float, bool] (default: False)": "Add jitter to the stripplot (only when stripplot is True)\nSee stripplot().",
            "size int (default: 1)": "Size of the jitter points.",
            "order Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Order in which to show the categories. Note: if dendrogram=True\nthe categories order will be given by the dendrogram and order\nwill be ignored.",
            "scale {\u2018area\u2019, \u2018count\u2019, \u2018width\u2019}Literal[\u2018area\u2019, \u2018count\u2019, \u2018width\u2019] (default: 'width')": "The method used to scale the width of each violin.\nIf \u2018width\u2019 (the default), each violin will have the same width.\nIf \u2018area\u2019, each violin will have the same area.\nIf \u2018count\u2019, a violin\u2019s width corresponds to the number of observations.",
            "yticklabels bool | NoneOptional[bool] (default: False)": "Set to true to view the y tick labels.",
            "row_palette str | NoneOptional[str] (default: None)": "Be default, median values are mapped to the violin color using a\ncolor map (see cmap argument). Alternatively, a \u2018row_palette` can\nbe given to color each violin plot row using a different colors.\nThe value should be a valid seaborn or matplotlib palette name\n(see color_palette()).\nAlternatively, a single color name or hex value can be passed,\ne.g. 'red' or '#cc33ff'.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax _AxesSubplot | NoneOptional[_AxesSubplot] (default: None)": "A matplotlib axes object. Only works if plotting a single component.",
            "vmin float | NoneOptional[float] (default: None)": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
            "vmax float | NoneOptional[float] (default: None)": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
            "vcenter float | NoneOptional[float] (default: None)": "The value representing the center of the color scale. Useful for diverging colormaps.",
            "norm Normalize | NoneOptional[Normalize] (default: None)": "Custom color normalization object from matplotlib. See\nhttps://matplotlib.org/stable/tutorials/colors/colormapnorms.html for details.",
            "kwds": "Are passed to violinplot()."
        },
        "Return type": "StackedViolin | dict | NoneUnion[StackedViolin, dict, None]",
        "Returns": "If return_fig is True, returns a StackedViolin object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.matrixplot.html": {
        "function_name": "scanpy.pl.matrixplot(adata, var_names, groupby, use_raw=None, log=False, num_categories=7, figsize=None, dendrogram=False, title=None, cmap='viridis', colorbar_title='Mean expression\\\\nin group', gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, values_df=None, swap_axes=False, show=None, save=None, ax=None, return_fig=False, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)",
        "description": "Creates a heatmap of the mean expression values per group of each var_names.\nThis function provides a convenient interface to the MatrixPlot\nclass. If you need more flexibility, you should use MatrixPlot\ndirectly.\nExamples\nUsing var_names as dict:\nGet Matrix object for fine tuning:\nThe axes used can be obtained using the get_axes() method",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "var_names str | Sequence[str] | MappingUnion[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]": "var_names should be a valid subset of adata.var_names.\nIf var_names is a mapping, then the key is used as label\nto group the values (see var_group_labels). The mapping values\nshould be sequences of valid adata.var_names. In this\ncase either coloring or \u2018brackets\u2019 are used for the grouping\nof var names depending on the plot. When var_names is a mapping,\nthen the var_group_labels and var_group_positions are set.",
            "groupby str | Sequence[str]Union[str, Sequence[str]]": "The key of the observation grouping to consider.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present.",
            "log bool (default: False)": "Plot on logarithmic axis.",
            "num_categories int (default: 7)": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
            "categories_order": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "Figure size when multi_panel=True.\nOtherwise the rcParam['figure.figsize] value is used.\nFormat is (width, height)",
            "dendrogram bool | strUnion[bool, str] (default: False)": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the groupby categories is added.\nThe dendrogram information is computed using scanpy.tl.dendrogram().\nIf tl.dendrogram has not been called previously the function is called\nwith default parameters.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols.\nBy default var_names refer to the index column of the .var DataFrame.\nSetting this option allows alternative names to be used.",
            "var_group_positions Sequence[Tuple[int, int]] | NoneOptional[Sequence[Tuple[int, int]]] (default: None)": "Use this parameter to highlight groups of var_names.\nThis will draw a \u2018bracket\u2019 or a color block between the given start and end\npositions. If the parameter var_group_labels is set, the corresponding\nlabels are added on top/left. E.g. var_group_positions=[(4,10)]\nwill add a bracket between the fourth var_name and the tenth var_name.\nBy giving more positions, more brackets/color blocks are drawn.",
            "var_group_labels Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Labels for each of the var_group_positions that want to be highlighted.",
            "var_group_rotation float | NoneOptional[float] (default: None)": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,\nthen the layer is plotted. layer takes precedence over use_raw.",
            "title str | NoneOptional[str] (default: None)": "Title for the figure",
            "colorbar_title str | NoneOptional[str] (default: 'Mean expression\\\\nin group')": "Title for the color bar. New line character (n) can be used.",
            "cmap str | NoneOptional[str] (default: 'viridis')": "String denoting matplotlib color map.",
            "standard_scale {\u2018var\u2019, \u2018group\u2019}Literal[\u2018var\u2019, \u2018group\u2019] (default: None)": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
            "swap_axes bool (default: False)": "By default, the x axis contains var_names (e.g. genes) and the y axis\nthe groupby categories. By setting swap_axes then x are the\ngroupby categories and y the var_names.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns DotPlot object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax _AxesSubplot | NoneOptional[_AxesSubplot] (default: None)": "A matplotlib axes object. Only works if plotting a single component.",
            "vmin float | NoneOptional[float] (default: None)": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
            "vmax float | NoneOptional[float] (default: None)": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
            "vcenter float | NoneOptional[float] (default: None)": "The value representing the center of the color scale. Useful for diverging colormaps.",
            "norm Normalize | NoneOptional[Normalize] (default: None)": "Custom color normalization object from matplotlib. See\nhttps://matplotlib.org/stable/tutorials/colors/colormapnorms.html for details.",
            "kwds": "Are passed to matplotlib.pyplot.pcolor()."
        },
        "Return type": "MatrixPlot | dict | NoneUnion[MatrixPlot, dict, None]",
        "Returns": "If return_fig is True, returns a MatrixPlot object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.clustermap.html": {
        "function_name": "scanpy.pl.clustermap(adata, obs_keys=None, use_raw=None, show=None, save=None, **kwds)",
        "description": "Hierarchically-clustered heatmap.\nWraps seaborn.clustermap() for AnnData.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "obs_keys str (default: None)": "Categorical annotation to plot with a different color map.\nCurrently, only a single key is supported.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Whether to use raw attribute of adata. Defaults to True if .raw is present.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "**kwds": "Keyword arguments passed to clustermap()."
        },
        "Returns": "If show is False, a ClusterGrid object\n(see clustermap()).\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.ranking.html": {
        "function_name": "scanpy.pl.ranking(adata, attr, keys, dictionary=None, indices=None, labels=None, color='black', n_points=30, log=False, include_lowest=False, show=None)",
        "description": "Plot rankings.\nSee, for example, how this is used in pl.pca_loadings.",
        "Parameters": {
            "adata AnnData": "The data.",
            "attr {\u2018var\u2019, \u2018obs\u2019, \u2018uns\u2019, \u2018varm\u2019, \u2018obsm\u2019}Literal[\u2018var\u2019, \u2018obs\u2019, \u2018uns\u2019, \u2018varm\u2019, \u2018obsm\u2019]": "The attribute of AnnData that contains the score.",
            "keys str | Sequence[str]Union[str, Sequence[str]]": "The scores to look up an array from the attribute of adata."
        },
        "Returns": "Returns matplotlib gridspec with access to the axes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pl.dendrogram.html": {
        "function_name": "scanpy.pl.dendrogram(adata, groupby, *, dendrogram_key=None, orientation='top', remove_labels=False, show=None, save=None, ax=None)",
        "description": "Plots a dendrogram of the categories defined in groupby.\nSee dendrogram().\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groupby str": "Categorical data column used to create the dendrogram",
            "dendrogram_key str | NoneOptional[str] (default: None)": "Key under with the dendrogram information was stored.\nBy default the dendrogram information is stored under\n.uns[f'dendrogram_{groupby}'].",
            "orientation {\u2018top\u2019, \u2018bottom\u2019, \u2018left\u2019, \u2018right\u2019}Literal[\u2018top\u2019, \u2018bottom\u2019, \u2018left\u2019, \u2018right\u2019] (default: 'top')": "Origin of the tree. Will grow into the opposite direction.",
            "remove_labels bool (default: False)": "Don\u2019t draw labels. Used e.g. by scanpy.pl.matrixplot()\nto annotate matrix columns/rows.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Returns": "matplotlib.axes.Axes\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.highest_expr_genes.html": {
        "function_name": "scanpy.pl.highest_expr_genes(adata, n_top=30, show=None, save=None, ax=None, gene_symbols=None, log=False, **kwds)",
        "description": "Fraction of counts assigned to each gene over all cells.\nComputes, for each gene, the fraction of counts assigned to that gene within\na cell. The n_top genes with the highest mean fraction over all cells are\nplotted as boxplots.\nThis plot is similar to the scater package function plotHighestExprs(type\n= \"highest-expression\"), see here. Quoting\nfrom there:",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_top int (default: 30)": "Number of top",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Key for field in .var that stores gene symbols if you do not want to use .var_names.",
            "log bool (default: False)": "Plot x-axis in log scale",
            "**kwds": "Are passed to boxplot()."
        },
        "Returns": "If show==False a Axes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.filter_genes_dispersion.html": {
        "function_name": "scanpy.pl.filter_genes_dispersion(result, log=False, show=None, save=None)",
        "description": "Plot dispersions versus means for genes.\nProduces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() of Seurat.",
        "Parameters": {
            "result recarray": "Adata of pp.highly_variable_genes() also works.",
            "log bool (default: False)": "Plot on logarithmic axes.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{'.pdf', '.png', '.svg'}}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.highly_variable_genes.html": {
        "function_name": "scanpy.pl.highly_variable_genes(adata_or_result, log=False, show=None, save=None, highly_variable_genes=True)",
        "description": "Plot dispersions or normalized variance versus means for genes.\nProduces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() and\nVariableFeaturePlot() of Seurat.",
        "Parameters": {
            "adata": "Result of highly_variable_genes().",
            "log bool (default: False)": "Plot on logarithmic axes.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{'.pdf', '.png', '.svg'}}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.pca.html": {
        "function_name": "scanpy.pl.pca(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', annotate_var_explained=False, **kwargs)",
        "description": "Scatter plot in PCA coordinates.\nUse the parameter annotate_var_explained to annotate the explained variance.\nExamples\nColour points by discrete variable (Louvain clusters).\nColour points by gene expression.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "annotate_var_explained bool (default: False)": "",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.pca_loadings.html": {
        "function_name": "scanpy.pl.pca_loadings(adata, components=None, include_lowest=True, n_points=None, show=None, save=None)",
        "description": "Rank genes according to contributions to PCs.\nExamples\nShow first 3 components loadings",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "components str | Sequence[int] | NoneUnion[str, Sequence[int], None] (default: None)": "For example, '1,2,3' means [1, 2, 3], first, second, third\nprincipal component.",
            "include_lowest bool (default: True)": "Whether to show the variables with both highest and lowest loadings.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "n_points int | NoneOptional[int] (default: None)": "Number of variables to plot for each component.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.pca_variance_ratio.html": {
        "function_name": "scanpy.pl.pca_variance_ratio(adata, n_pcs=30, log=False, show=None, save=None)",
        "description": "Plot the variance ratio.",
        "Parameters": {
            "n_pcs int (default: 30)": "Number of PCs to show.",
            "log bool (default: False)": "Plot on logarithmic scale..",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.pca_overview.html": {
        "function_name": "scanpy.pl.pca_overview(adata, **params)",
        "description": "Plot PCA results.\nThe parameters are the ones of the scatter plot. Call pca_ranking separately\nif you want to change the default settings.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color": "Keys for observation/cell annotation either as list [\"ann1\", \"ann2\"] or\nstring \"ann1,ann2,...\".",
            "use_raw": "Use raw attribute of adata if present.",
            "sort_order": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection": "Projection of plot (default: '2d').",
            "colorbar_loc": "Where to place the colorbar for continous variables. If None, no colorbar\nis added.",
            "size": "Point size. If None, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
            "frameon": "Draw a frame around the scatter plot. Defaults to value set in\nset_figure_params(), defaults to True.",
            "title": "Provide title for panels either as string or list of strings,\ne.g. ['title1', 'title2', ...].",
            "ncols": "Number of panels per row.",
            "wspace": "Adjust the width of the space between multiple panels.",
            "hspace": "Adjust the height of the space between multiple panels.",
            "return_fig": "Return the matplotlib figure.",
            "kwargs": "Arguments to pass to matplotlib.pyplot.scatter(),\nfor instance: the maximum and minimum values (e.g. vmin=-2, vmax=5).",
            "show": "Show the plot, do not return axis.",
            "save": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.tsne.html": {
        "function_name": "scanpy.pl.tsne(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot in tSNE basis.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.umap.html": {
        "function_name": "scanpy.pl.umap(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot in UMAP basis.\nExamples\nColour points by discrete variable (Louvain clusters).\nColour points by gene expression.\nPlot muliple umaps for different gene expressions.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.diffmap.html": {
        "function_name": "scanpy.pl.diffmap(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot in Diffusion Map basis.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.draw_graph.html": {
        "function_name": "scanpy.pl.draw_graph(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', layout=None, **kwargs)",
        "description": "Scatter plot in graph-drawing basis.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "layout {\u2018fa\u2019, \u2018fr\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018drl\u2019, \u2018eq_tree\u2019, Ellipsis} | NoneOptional[Literal[\u2018fa\u2019, \u2018fr\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018drl\u2019, \u2018eq_tree\u2019, Ellipsis]] (default: None)": "One of the draw_graph() layouts.\nBy default, the last computed layout is used.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.spatial.html": {
        "function_name": "scanpy.pl.spatial(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color=None, na_in_legend=True, size=1.0, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', basis='spatial', img=None, img_key=Empty.token, library_id=Empty.token, crop_coord=None, alpha_img=1.0, bw=False, spot_size=None, **kwargs)",
        "description": "Scatter plot in spatial coordinates.\nThis function allows overlaying data on top of images.\nUse the parameter img_key to see the image in the background\nAnd the parameter library_id to select the image.\nBy default, 'hires' and 'lowres' are attempted.\nUse crop_coord, alpha_img, and bw to control how it is displayed.\nUse size to scale the size of the Visium spots plotted on top.\nAs this function is designed to for imaging data, there are two key assumptions\nabout how coordinates are handled:\n1. The origin (e.g (0, 0)) is at the top left \u2013 as is common convention\nwith image data.\n2. Coordinates are in the pixel space of the source image, so an equal\naspect ratio is assumed.\nIf your anndata object has a \"spatial\" entry in .uns, the img_key\nand library_id parameters to find values for img, scale_factor,\nand spot_size arguments. Alternatively, these values be passed directly.\nExamples\nThis function behaves very similarly to other embedding plots like\numap()",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "library_id str | None | EmptyUnion[str, None, Empty] (default: <Empty.token: 0>)": "library_id for Visium data, e.g. key in adata.uns[\"spatial\"].",
            "img_key str | None | EmptyUnion[str, None, Empty] (default: <Empty.token: 0>)": "Key for image data, used to get img and scale_factor from \"images\"\nand \"scalefactors\" entires for this library. To use spatial coordinates,\nbut not plot an image, pass img_key=None.",
            "img ndarray | NoneOptional[ndarray] (default: None)": "image data to plot, overrides img_key.",
            "scale_factor float | NoneOptional[float] (default: None)": "Scaling factor used to map from coordinate space to pixel space.\nFound by default if library_id and img_key can be resolved.\nOtherwise defaults to 1..",
            "spot_size float | NoneOptional[float] (default: None)": "Diameter of spot (in coordinate space) for each point. Diameter\nin pixels of the spots will be size * spot_size * scale_factor.\nThis argument is required if it cannot be resolved from library info.",
            "crop_coord Tuple[int, int, int, int] (default: None)": "Coordinates to use for cropping the image (left, right, top, bottom).\nThese coordinates are expected to be in pixel space (same as basis)\nand will be transformed by scale_factor.\nIf not provided, image is automatically cropped to bounds of basis,\nplus a border.",
            "alpha_img float (default: 1.0)": "Alpha value for image.",
            "bw bool | NoneOptional[bool] (default: False)": "Plot image data in gray scale.",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.embedding.html": {
        "function_name": "scanpy.pl.embedding(adata, basis, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot for user specified embedding basis (e.g. umap, pca, etc)",
        "Parameters": {
            "basis str": "Name of the obsm basis to use.",
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Figure | Axes | NoneUnion[Figure, Axes, None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.embedding_density.html": {
        "function_name": "scanpy.pl.embedding_density(adata, basis='umap', key=None, groupby=None, group='all', color_map='YlOrRd', bg_dotsize=80, fg_dotsize=180, vmax=1, vmin=0, vcenter=None, norm=None, ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, **kwargs)",
        "description": "Plot the density of cells in an embedding (per condition).\nPlots the gaussian kernel density estimates (over condition) from the\nsc.tl.embedding_density() output.\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.\nExamples\nPlot all categories be default\nPlot selected categories",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "basis str (default: 'umap')": "The embedding over which the density was calculated. This embedded\nrepresentation should be found in adata.obsm['X_[basis]']`.",
            "key str | NoneOptional[str] (default: None)": "Name of the .obs covariate that contains the density estimates. Alternatively, pass groupby.",
            "groupby str | NoneOptional[str] (default: None)": "Name of the condition used in tl.embedding_density. Alternatively, pass key.",
            "group str | List[str] | NoneUnion[str, List[str], None] (default: 'all')": "The category in the categorical observation annotation to be plotted.\nFor example, \u2018G1\u2019 in the cell cycle \u2018phase\u2019 covariate. If all categories\nare to be plotted use group=\u2019all\u2019 (default), If multiple categories\nwant to be plotted use a list (e.g.: [\u2018G1\u2019, \u2018S\u2019]. If the overall density\nwants to be ploted set group to \u2018None\u2019.",
            "color_map Colormap | strUnion[Colormap, str] (default: 'YlOrRd')": "Matplolib color map to use for density plotting.",
            "bg_dotsize int | NoneOptional[int] (default: 80)": "Dot size for background data points not in the group.",
            "fg_dotsize int | NoneOptional[int] (default: 180)": "Dot size for foreground data points in the group.",
            "vmin int | NoneOptional[int] (default: 0)": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or None. If\nvmin is a string and has the format pN, this is interpreted as a vmin=percentile(N).\nFor example vmin=\u2019p1.5\u2019 is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, def my_vmin(values): return\nnp.mean(values) and then set vmin=my_vmin. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib scatter function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example vmin=[0.1, 'p1', None, my_vmin]",
            "vmax int | NoneOptional[int] (default: 1)": "The value representing the upper limit of the color scale. The format is the same as for vmin.",
            "vcenter int | NoneOptional[int] (default: None)": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for vmin.\nExample: sc.pl.umap(adata, color=\u2019TREM2\u2019, vcenter=\u2019p50\u2019, cmap=\u2019RdBu_r\u2019)",
            "ncols int | NoneOptional[int] (default: 4)": "Number of panels per row.",
            "wspace None (default: None)": "Adjust the width of the space between multiple panels.",
            "hspace float | NoneOptional[float] (default: 0.25)": "Adjust the height of the space between multiple panels.",
            "return_fig bool | NoneOptional[bool] (default: None)": "Return the matplotlib figure.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.dpt_groups_pseudotime.html": {
        "function_name": "scanpy.pl.dpt_groups_pseudotime(adata, color_map=None, palette=None, show=None, save=None, marker='.')",
        "description": "Plot groups and pseudotime.",
        "Parameters": {}
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.dpt_timeseries.html": {
        "function_name": "scanpy.pl.dpt_timeseries(adata, color_map=None, show=None, save=None, as_heatmap=True, marker='.')",
        "description": "Heatmap of pseudotime series.",
        "Parameters": {
            "as_heatmap bool (default: True)": "Plot the timeseries as heatmap."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.paga.html": {
        "function_name": "scanpy.pl.paga(adata, threshold=None, color=None, layout=None, layout_kwds=mappingproxy({}), init_pos=None, root=0, labels=None, single_component=False, solid_edges='connectivities', dashed_edges=None, transitions=None, fontsize=None, fontweight='bold', fontoutline=None, text_kwds=mappingproxy({}), node_size_scale=1.0, node_size_power=0.5, edge_width_scale=1.0, min_edge_width=None, max_edge_width=None, arrowsize=30, title=None, left_margin=0.01, random_state=0, pos=None, normalize_to_color=False, cmap=None, cax=None, colorbar=None, cb_kwds=mappingproxy({}), frameon=None, add_pos=True, export_to_gexf=False, use_raw=True, colors=None, groups=None, plot=True, show=None, save=None, ax=None)",
        "description": "Plot the PAGA graph through thresholding low-connectivity edges.\nCompute a coarse-grained layout of the data. Reuse this by passing\ninit_pos='paga' to umap() or\ndraw_graph() and obtain embeddings with more meaningful\nglobal topology [Wolf19].\nThis uses ForceAtlas2 or igraph\u2019s layout algorithms for most layouts [Csardi06].\nExamples\nYou can increase node and edge sizes by specifying additional arguments.\nNotes\nWhen initializing the positions, note that \u2013 for some reason \u2013 igraph\nmirrors coordinates along the x axis\u2026 that is, you should increase the\nmaxiter parameter by 1 if the layout is flipped.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "threshold float | NoneOptional[float] (default: None)": "Do not draw edges for weights below this threshold. Set to 0 if you want\nall edges. Discarding low-connectivity edges helps in getting a much\nclearer picture of the graph.",
            "color str | Mapping | NoneUnion[str, Mapping[Union[str, int], Mapping[Any, float]], None] (default: None)": "Gene name or obs annotation defining the node colors.\nAlso plots the degree of the abstracted graph when\npassing {'degree_dashed', 'degree_solid'}.\nCan be also used to visualize pie chart at each node in the following form:\n{<group name or index>: {<color>: <fraction>, ...}, ...}. If the fractions\ndo not sum to 1, a new category called 'rest' colored grey will be created.",
            "labels str | Sequence[str] | Mapping | NoneUnion[str, Sequence[str], Mapping[str, str], None] (default: None)": "The node labels. If None, this defaults to the group labels stored in\nthe categorical for which paga() has been computed.",
            "pos ndarray | str | Path | NoneUnion[ndarray, str, Path, None] (default: None)": "Two-column array-like storing the x and y coordinates for drawing.\nOtherwise, path to a .gdf file that has been exported from Gephi or\na similar graph visualization software.",
            "layout {\u2018fa\u2019, \u2018fr\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018drl\u2019, \u2018eq_tree\u2019, Ellipsis} | NoneOptional[Literal[\u2018fa\u2019, \u2018fr\u2019, \u2018rt\u2019, \u2018rt_circular\u2019, \u2018drl\u2019, \u2018eq_tree\u2019, Ellipsis]] (default: None)": "Plotting layout that computes positions.\n'fa' stands for \u201cForceAtlas2\u201d,\n'fr' stands for \u201cFruchterman-Reingold\u201d,\n'rt' stands for \u201cReingold-Tilford\u201d,\n'eq_tree' stands for \u201ceqally spaced tree\u201d.\nAll but 'fa' and 'eq_tree' are igraph layouts.\nAll other igraph layouts are also permitted.\nSee also parameter pos and draw_graph().",
            "layout_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Keywords for the layout.",
            "init_pos ndarray | NoneOptional[ndarray] (default: None)": "Two-column array storing the x and y coordinates for initializing the\nlayout.",
            "random_state int | NoneOptional[int] (default: 0)": "For layouts with random initialization like 'fr', change this to use\ndifferent intial states for the optimization. If None, the initial\nstate is not reproducible.",
            "root int | str | Sequence[int] | NoneUnion[int, str, Sequence[int], None] (default: 0)": "If choosing a tree layout, this is the index of the root node or a list\nof root node indices. If this is a non-empty vector then the supplied\nnode IDs are used as the roots of the trees (or a single tree if the\ngraph is connected). If this is None or an empty list, the root\nvertices are automatically calculated based on topological sorting.",
            "transitions str | NoneOptional[str] (default: None)": "Key for .uns['paga'] that specifies the matrix that stores the\narrows, for instance 'transitions_confidence'.",
            "solid_edges str (default: 'connectivities')": "Key for .uns['paga'] that specifies the matrix that stores the edges\nto be drawn solid black.",
            "dashed_edges str | NoneOptional[str] (default: None)": "Key for .uns['paga'] that specifies the matrix that stores the edges\nto be drawn dashed grey. If None, no dashed edges are drawn.",
            "single_component bool (default: False)": "Restrict to largest connected component.",
            "fontsize int | NoneOptional[int] (default: None)": "Font size for node labels.",
            "fontoutline int | NoneOptional[int] (default: None)": "Width of the white outline around fonts.",
            "text_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Keywords for text().",
            "node_size_scale float (default: 1.0)": "Increase or decrease the size of the nodes.",
            "node_size_power float (default: 0.5)": "The power with which groups sizes influence the radius of the nodes.",
            "edge_width_scale float (default: 1.0)": "Edge with scale in units of rcParams['lines.linewidth'].",
            "min_edge_width float | NoneOptional[float] (default: None)": "Min width of solid edges.",
            "max_edge_width float | NoneOptional[float] (default: None)": "Max width of solid and dashed edges.",
            "arrowsize int (default: 30)": "For directed graphs, choose the size of the arrow head head\u2019s length and\nwidth. See :py:class: matplotlib.patches.FancyArrowPatch for attribute\nmutation_scale for more info.",
            "export_to_gexf bool (default: False)": "Export to gexf format to be read by graph visualization programs such as\nGephi.",
            "normalize_to_color bool (default: False)": "Whether to normalize categorical plots to color or the underlying\ngrouping.",
            "cmap str | ColormapUnion[str, Colormap] (default: None)": "The color map.",
            "cax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object for a potential colorbar.",
            "cb_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Keyword arguments for Colorbar,\nfor instance, ticks.",
            "add_pos bool (default: True)": "Add the positions to adata.uns['paga'].",
            "title str | NoneOptional[str] (default: None)": "Provide a title.",
            "frameon bool | NoneOptional[bool] (default: None)": "Draw a frame around the PAGA graph.",
            "plot bool (default: True)": "If False, do not create the figure, simply compute the layout.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False, one or more Axes objects.\nAdds 'pos' to adata.uns['paga'] if add_pos is True.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.paga_path.html": {
        "function_name": "scanpy.pl.paga_path(adata, nodes, keys, use_raw=True, annotations=('dpt_pseudotime',), color_map=None, color_maps_annotations=mappingproxy({'dpt_pseudotime': 'Greys'}), palette_groups=None, n_avg=1, groups_key=None, xlim=(None, None), title=None, left_margin=None, ytick_fontsize=None, title_fontsize=None, show_node_names=True, show_yticks=True, show_colorbar=True, legend_fontsize=None, legend_fontweight=None, normalize_to_zero_one=False, as_heatmap=True, return_data=False, show=None, save=None, ax=None)",
        "description": "Gene expression and annotation changes along paths in the abstracted graph.",
        "Parameters": {
            "adata AnnData": "An annotated data matrix.",
            "nodes Sequence[Union[str, int]]": "A path through nodes of the abstracted graph, that is, names or indices\n(within .categories) of groups that have been used to run PAGA.",
            "keys Sequence[str]": "Either variables in adata.var_names or annotations in\nadata.obs. They are plotted using color_map.",
            "use_raw bool (default: True)": "Use adata.raw for retrieving gene expressions if it has been set.",
            "annotations Sequence[str] (default: ('dpt_pseudotime',))": "Plot these keys with color_maps_annotations. Need to be keys for\nadata.obs.",
            "color_map str | Colormap | NoneUnion[str, Colormap, None] (default: None)": "Matplotlib colormap.",
            "color_maps_annotations MappingMapping[str, Union[str, Colormap]] (default: mappingproxy({'dpt_pseudotime': 'Greys'}))": "Color maps for plotting the annotations. Keys of the dictionary must\nappear in annotations.",
            "palette_groups Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "Ususally, use the same sc.pl.palettes... as used for coloring the\nabstracted graph.",
            "n_avg int (default: 1)": "Number of data points to include in computation of running average.",
            "groups_key str | NoneOptional[str] (default: None)": "Key of the grouping used to run PAGA. If None, defaults to\nadata.uns['paga']['groups'].",
            "as_heatmap bool (default: True)": "Plot the timeseries as heatmap. If not plotting as heatmap,\nannotations have no effect.",
            "show_node_names bool (default: True)": "Plot the node names on the nodes bar.",
            "show_colorbar bool (default: True)": "Show the colorbar.",
            "show_yticks bool (default: True)": "Show the y ticks.",
            "normalize_to_zero_one bool (default: False)": "Shift and scale the running average to [0, 1] per gene.",
            "return_data bool (default: False)": "Return the timeseries data in addition to the axes if True.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object."
        },
        "Return type": "Axes | NoneOptional[Axes]",
        "Returns": "A Axes object, if ax is None, else None.\nIf return_data, return the timeseries data in addition to an axes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.paga_compare.html": {
        "function_name": "scanpy.pl.paga_compare(adata, basis=None, edges=False, color=None, alpha=None, groups=None, components=None, projection='2d', legend_loc='on data', legend_fontsize=None, legend_fontweight='bold', legend_fontoutline=None, color_map=None, palette=None, frameon=False, size=None, title=None, right_margin=None, left_margin=0.05, show=None, save=None, title_graph=None, groups_graph=None, *, pos=None, **paga_graph_params)",
        "description": "Scatter and PAGA graph side-by-side.\nConsists in a scatter plot and the abstracted graph. See\npaga() for all related parameters.\nSee paga_path() for visualizing gene changes along paths\nthrough the abstracted graph.\nAdditional parameters are as follows.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "kwds_scatter": "Keywords for scatter().",
            "kwds_paga": "Keywords for paga()."
        },
        "Returns": "A list of Axes if show is False.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups.html": {
        "function_name": "scanpy.pl.rank_genes_groups(adata, groups=None, n_genes=20, gene_symbols=None, key='rank_genes_groups', fontsize=8, ncols=4, sharey=True, show=None, save=None, ax=None, **kwds)",
        "description": "Plot ranking of genes.\nExamples\nPlot top 10 genes (default 20 genes)",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Key for field in .var that stores gene symbols if you do not want to\nuse .var_names.",
            "n_genes int (default: 20)": "Number of genes to show.",
            "fontsize int (default: 8)": "Fontsize for gene names.",
            "ncols int (default: 4)": "Number of panels shown per row.",
            "sharey bool (default: True)": "Controls if the y-axis of each panels should be shared. But passing\nsharey=False, each panel has its own y-axis range.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_violin.html": {
        "function_name": "scanpy.pl.rank_genes_groups_violin(adata, groups=None, n_genes=20, gene_names=None, gene_symbols=None, use_raw=None, key=None, split=True, scale='width', strip=True, jitter=True, size=1, ax=None, show=None, save=None)",
        "description": "Plot ranking of genes for all tested comparisons.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups Sequence[str] | NoneOptional[Sequence[str]] (default: None)": "List of group names.",
            "n_genes int (default: 20)": "Number of genes to show. Is ignored if gene_names is passed.",
            "gene_names Iterable[str] | NoneOptional[Iterable[str]] (default: None)": "List of genes to plot. Is only useful if interested in a custom gene list,\nwhich is not the result of scanpy.tl.rank_genes_groups().",
            "gene_symbols str | NoneOptional[str] (default: None)": "Key for field in .var that stores gene symbols if you do not want to\nuse .var_names displayed in the plot.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use raw attribute of adata if present. Defaults to the value that\nwas used in rank_genes_groups().",
            "split bool (default: True)": "Whether to split the violins or not.",
            "scale str (default: 'width')": "See violinplot().",
            "strip bool (default: True)": "Show a strip plot on top of the violin plot.",
            "jitter int | float | boolUnion[int, float, bool] (default: True)": "If set to 0, no points are drawn. See stripplot().",
            "size int (default: 1)": "Size of the jitter points.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_stacked_violin.html": {
        "function_name": "scanpy.pl.rank_genes_groups_stacked_violin(adata, groups=None, n_genes=None, groupby=None, gene_symbols=None, *, var_names=None, min_logfoldchange=None, key=None, show=None, save=None, return_fig=False, **kwds)",
        "description": "Plot ranking of genes using stacked_violin plot\n(see stacked_violin())\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "n_genes int | NoneOptional[int] (default: None)": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\ngene_names is passed.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into num_categories (see dotplot()).",
            "min_logfoldchange float | NoneOptional[float] (default: None)": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
            "key str | NoneOptional[str] (default: None)": "Key used to store the ranking results in adata.uns.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns StackedViolin object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "**kwds": "Are passed to stacked_violin()."
        },
        "Returns": "If return_fig is True, returns a StackedViolin object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_heatmap.html": {
        "function_name": "scanpy.pl.rank_genes_groups_heatmap(adata, groups=None, n_genes=None, groupby=None, gene_symbols=None, var_names=None, min_logfoldchange=None, key=None, show=None, save=None, **kwds)",
        "description": "Plot ranking of genes using heatmap plot (see heatmap())\nExamples\nShow gene names per group on the heatmap\nPlot top 5 genes per group (default 10 genes)",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "n_genes int | NoneOptional[int] (default: None)": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\ngene_names is passed.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into num_categories (see dotplot()).",
            "min_logfoldchange float | NoneOptional[float] (default: None)": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
            "key str (default: None)": "Key used to store the ranking results in adata.uns.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "**kwds": "Are passed to heatmap().",
            "show": "Show the plot, do not return axis.",
            "save": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_dotplot.html": {
        "function_name": "scanpy.pl.rank_genes_groups_dotplot(adata, groups=None, n_genes=None, groupby=None, values_to_plot=None, var_names=None, gene_symbols=None, min_logfoldchange=None, key=None, show=None, save=None, return_fig=False, **kwds)",
        "description": "Plot ranking of genes using dotplot plot (see dotplot())\nExamples\nPlot top 2 genes per group.\nPlot with scaled expressions for easier identification of differences.\nPlot logfoldchanges instead of gene expression. In this case a diverging colormap\nlike bwr or seismic works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this n_genes=-4 is used\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "n_genes int | NoneOptional[int] (default: None)": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\ngene_names is passed.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into num_categories (see dotplot()).",
            "min_logfoldchange float | NoneOptional[float] (default: None)": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
            "key str | NoneOptional[str] (default: None)": "Key used to store the ranking results in adata.uns.",
            "values_to_plot {\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019, \u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019} | NoneOptional[Literal[\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019, \u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019]] (default: None)": "Instead of the mean gene value, plot the values computed by sc.rank_genes_groups.\nThe options are: [\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019,\n\u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019]. When plotting logfoldchanges a divergent\ncolormap is recommended. See examples below.",
            "var_names Sequence[str] | Mapping | NoneUnion[Sequence[str], Mapping[str, Sequence[str]], None] (default: None)": "Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\nto check their fold changes or p-values, instead of the top/bottom genes. The\nvar_names could be a dictionary or a list as in dotplot() or\nmatrixplot(). See examples below.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns DotPlot object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "**kwds": "Are passed to dotplot()."
        },
        "Returns": "If return_fig is True, returns a DotPlot object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_matrixplot.html": {
        "function_name": "scanpy.pl.rank_genes_groups_matrixplot(adata, groups=None, n_genes=None, groupby=None, values_to_plot=None, var_names=None, gene_symbols=None, min_logfoldchange=None, key=None, show=None, save=None, return_fig=False, **kwds)",
        "description": "Plot ranking of genes using matrixplot plot (see matrixplot())\nExamples\nPlot logfoldchanges instead of gene expression. In this case a diverging colormap\nlike bwr or seismic works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this n_genes=-4 is used\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "n_genes int | NoneOptional[int] (default: None)": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\ngene_names is passed.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into num_categories (see dotplot()).",
            "min_logfoldchange float | NoneOptional[float] (default: None)": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
            "key str | NoneOptional[str] (default: None)": "Key used to store the ranking results in adata.uns.",
            "values_to_plot {\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019, \u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019} | NoneOptional[Literal[\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019, \u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019]] (default: None)": "Instead of the mean gene value, plot the values computed by sc.rank_genes_groups.\nThe options are: [\u2018scores\u2019, \u2018logfoldchanges\u2019, \u2018pvals\u2019, \u2018pvals_adj\u2019,\n\u2018log10_pvals\u2019, \u2018log10_pvals_adj\u2019]. When plotting logfoldchanges a divergent\ncolormap is recommended. See examples below.",
            "var_names Sequence[str] | Mapping | NoneUnion[Sequence[str], Mapping[str, Sequence[str]], None] (default: None)": "Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\nto check their fold changes or p-values, instead of the top/bottom genes. The\nvar_names could be a dictionary or a list as in dotplot() or\nmatrixplot(). See examples below.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "return_fig bool | NoneOptional[bool] (default: False)": "Returns MatrixPlot object. Useful for fine-tuning\nthe plot. Takes precedence over show=False.",
            "**kwds": "Are passed to matrixplot()."
        },
        "Returns": "If return_fig is True, returns a MatrixPlot object,\nelse if show is false, return axes dict\n"
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.rank_genes_groups_tracksplot.html": {
        "function_name": "scanpy.pl.rank_genes_groups_tracksplot(adata, groups=None, n_genes=None, groupby=None, var_names=None, gene_symbols=None, min_logfoldchange=None, key=None, show=None, save=None, **kwds)",
        "description": "Plot ranking of genes using heatmap plot (see heatmap())\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "groups str | Sequence[str]Union[str, Sequence[str]] (default: None)": "The groups for which to show the gene ranking.",
            "n_genes int | NoneOptional[int] (default: None)": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\ngene_names is passed.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "groupby str | NoneOptional[str] (default: None)": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into num_categories (see dotplot()).",
            "min_logfoldchange float | NoneOptional[float] (default: None)": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
            "key str | NoneOptional[str] (default: None)": "Key used to store the ranking results in adata.uns.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | NoneOptional[bool] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax": "A matplotlib axes object. Only works if plotting a single component.",
            "**kwds": "Are passed to tracksplot().",
            "show": "Show the plot, do not return axis.",
            "save": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/api/generated/scanpy.pl.sim.html": {
        "function_name": "scanpy.pl.sim(adata, tmax_realization=None, as_heatmap=False, shuffle=False, show=None, save=None, marker='.')",
        "description": "Plot results of simulation.",
        "Parameters": {
            "tmax_realization int | NoneOptional[int] (default: None)": "Number of observations in one realization of the time series. The data matrix\nadata.X consists in concatenated realizations.",
            "as_heatmap bool (default: False)": "Plot the timeseries as heatmap.",
            "shuffle bool (default: False)": "Shuffle the data.",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{'.pdf', '.png', '.svg'}}."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.read.html": {
        "function_name": "scanpy.read(filename, backed=None, sheet=None, ext=None, delimiter=None, first_column_names=False, backup_url=None, cache=False, cache_compression=Empty.token, **kwargs)",
        "description": "Read file and return AnnData object.\nTo speed up reading, consider passing cache=True, which creates an hdf5\ncache file.",
        "Parameters": {
            "filename Path | strUnion[Path, str]": "If the filename has no file extension, it is interpreted as a key for\ngenerating a filename via sc.settings.writedir / (filename +\nsc.settings.file_format_data).  This is the same behavior as in\nsc.read(filename, ...).",
            "backed {\u2018r\u2019, \u2018r+\u2019} | NoneOptional[Literal[\u2018r\u2019, \u2018r+\u2019]] (default: None)": "If 'r', load AnnData in backed mode instead\nof fully loading it into memory (memory mode). If you want to modify\nbacked attributes of the AnnData object, you need to choose 'r+'.",
            "sheet str | NoneOptional[str] (default: None)": "Name of sheet/table in hdf5 or Excel file.",
            "ext str | NoneOptional[str] (default: None)": "Extension that indicates the file type. If None, uses extension of\nfilename.",
            "delimiter str | NoneOptional[str] (default: None)": "Delimiter that separates data within text file. If None, will split at\narbitrary number of white spaces, which is different from enforcing\nsplitting at any single white space ' '.",
            "first_column_names bool (default: False)": "Assume the first column stores row names. This is only necessary if\nthese are not strings: strings in the first column are automatically\nassumed to be row names.",
            "backup_url str | NoneOptional[str] (default: None)": "Retrieve the file from an URL if not present on disk.",
            "cache bool (default: False)": "If False, read from source, if True, read from fast \u2018h5ad\u2019 cache.",
            "cache_compression {\u2018gzip\u2019, \u2018lzf\u2019} | None | EmptyUnion[Literal[\u2018gzip\u2019, \u2018lzf\u2019], None, Empty] (default: <Empty.token: 0>)": "See the h5py Filter pipeline.\n(Default: settings.cache_compression)",
            "kwargs": "Parameters passed to read_loom()."
        },
        "Return type": "AnnData",
        "Returns": "An AnnData object\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.get.obs_df.html": {
        "function_name": "scanpy.get.obs_df(adata, keys=(), obsm_keys=(), *, layer=None, gene_symbols=None, use_raw=False)",
        "description": "Return values for observations in adata.\nExamples\nGetting value for plotting:\nCalculating mean expression for marker genes by cluster:",
        "Parameters": {
            "adata AnnData": "AnnData object to get values from.",
            "keys Iterable[str] (default: ())": "Keys from either .var_names, .var[gene_symbols], or .obs.columns.",
            "obsm_keys Iterable[Tuple[str, int]] (default: ())": "Tuple of (key from obsm, column index of obsm[key]).",
            "layer str (default: None)": "Layer of adata to use as expression values.",
            "gene_symbols str (default: None)": "Column of adata.var to search for keys in.",
            "use_raw bool (default: False)": "Whether to get expression values from adata.raw."
        },
        "Return type": "DataFrame",
        "Returns": "A dataframe with adata.obs_names as index, and values specified by keys\nand obsm_keys.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.get.var_df.html": {
        "function_name": "scanpy.get.var_df(adata, keys=(), varm_keys=(), *, layer=None)",
        "description": "Return values for observations in adata.",
        "Parameters": {
            "adata AnnData": "AnnData object to get values from.",
            "keys Iterable[str] (default: ())": "Keys from either .obs_names, or .var.columns.",
            "varm_keys Iterable[Tuple[str, int]] (default: ())": "Tuple of (key from varm, column index of varm[key]).",
            "layer str (default: None)": "Layer of adata to use as expression values."
        },
        "Return type": "DataFrame",
        "Returns": "A dataframe with adata.var_names as index, and values specified by keys\nand varm_keys.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.get.rank_genes_groups_df.html": {
        "function_name": "scanpy.get.rank_genes_groups_df(adata, group, *, key='rank_genes_groups', pval_cutoff=None, log2fc_min=None, log2fc_max=None, gene_symbols=None)",
        "description": "scanpy.tl.rank_genes_groups() results in the form of a\nDataFrame.\nExample",
        "Parameters": {
            "adata AnnData": "Object to get results from.",
            "group str | Iterable[str]Union[str, Iterable[str]]": "Which group (as in scanpy.tl.rank_genes_groups()\u2019s groupby\nargument) to return results from. Can be a list. All groups are\nreturned if groups is None.",
            "key str (default: 'rank_genes_groups')": "Key differential expression groups were stored under.",
            "pval_cutoff float | NoneOptional[float] (default: None)": "Return only adjusted p-values below the  cutoff.",
            "log2fc_min float | NoneOptional[float] (default: None)": "Minimum logfc to return.",
            "log2fc_max float | NoneOptional[float] (default: None)": "Maximum logfc to return.",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. Specifying\nthis will add that column to the returned dataframe."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.queries.biomart_annotations.html": {
        "function_name": "scanpy.queries.biomart_annotations(org, attrs, *, host='www.ensembl.org', use_cache=False)",
        "description": "Retrieve gene annotations from ensembl biomart.\nExamples\nRetrieve genes coordinates and chromosomes",
        "Parameters": {
            "org str": "Organism to query. Must be an organism in ensembl biomart. \u201chsapiens\u201d,\n\u201cmmusculus\u201d, \u201cdrerio\u201d, etc.",
            "attrs Iterable[str]": "Attributes to query biomart for.",
            "host str (default: 'www.ensembl.org')": "A valid BioMart host URL. Alternative values include archive urls (like\n\u201cgrch37.ensembl.org\u201d) or regional mirrors (like \u201cuseast.ensembl.org\u201d).",
            "use_cache bool (default: False)": "Whether pybiomart should use a cache for requests. Will create a\n.pybiomart.sqlite file in current directory if used."
        },
        "Return type": "DataFrame",
        "Returns": "Dataframe containing annotations.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.queries.gene_coordinates.html": {
        "function_name": "scanpy.queries.gene_coordinates(org, gene_name, *, gene_attr='external_gene_name', chr_exclude=(), host='www.ensembl.org', use_cache=False)",
        "description": "Retrieve gene coordinates for specific organism through BioMart.\nExamples",
        "Parameters": {
            "org str": "Organism to query. Must be an organism in ensembl biomart. \u201chsapiens\u201d,\n\u201cmmusculus\u201d, \u201cdrerio\u201d, etc.",
            "gene_name str": "The gene symbol (e.g. \u201chgnc_symbol\u201d for human) for which to retrieve\ncoordinates.",
            "gene_attr str (default: 'external_gene_name')": "The biomart attribute the gene symbol should show up for.",
            "chr_exclude Iterable[str] (default: ())": "A list of chromosomes to exclude from query.",
            "host str (default: 'www.ensembl.org')": "A valid BioMart host URL. Alternative values include archive urls (like\n\u201cgrch37.ensembl.org\u201d) or regional mirrors (like \u201cuseast.ensembl.org\u201d).",
            "use_cache bool (default: False)": "Whether pybiomart should use a cache for requests. Will create a\n.pybiomart.sqlite file in current directory if used."
        },
        "Return type": "DataFrame",
        "Returns": "Dataframe containing gene coordinates for the specified gene symbol.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.queries.mitochondrial_genes.html": {
        "function_name": "scanpy.queries.mitochondrial_genes(org, *, attrname='external_gene_name', host='www.ensembl.org', use_cache=False, chromosome='MT')",
        "description": "Mitochondrial gene symbols for specific organism through BioMart.\nExamples",
        "Parameters": {
            "org str": "Organism to query. Must be an organism in ensembl biomart. \u201chsapiens\u201d,\n\u201cmmusculus\u201d, \u201cdrerio\u201d, etc.",
            "attrname str (default: 'external_gene_name')": "Biomart attribute field to return. Possible values include\n\u201cexternal_gene_name\u201d, \u201censembl_gene_id\u201d, \u201chgnc_symbol\u201d, \u201cmgi_symbol\u201d,\nand \u201czfin_id_symbol\u201d.",
            "host str (default: 'www.ensembl.org')": "A valid BioMart host URL. Alternative values include archive urls (like\n\u201cgrch37.ensembl.org\u201d) or regional mirrors (like \u201cuseast.ensembl.org\u201d).",
            "use_cache bool (default: False)": "Whether pybiomart should use a cache for requests. Will create a\n.pybiomart.sqlite file in current directory if used.",
            "chromosome str (default: 'MT')": "Mitochrondrial chromosome name used in BioMart for organism."
        },
        "Return type": "DataFrame",
        "Returns": "Dataframe containing identifiers for mitochondrial genes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.queries.enrich.html": {
        "function_name": "scanpy.queries.enrich(container, *, org='hsapiens', gprofiler_kwargs=mappingproxy({}))",
        "description": "Get enrichment for DE results.\nThis is a thin convenience wrapper around the very useful gprofiler.\nThis method dispatches on the first argument, leading to the following two\nsignatures:\nWhere:\nExamples\nUsing sc.queries.enrich on a list of genes:\nUsing sc.queries.enrich on an anndata.AnnData object:",
        "Parameters": {
            "container Iterable[str] | MappingUnion[Iterable[str], Mapping[str, Iterable[str]]]": "Contains list of genes you\u2019d like to search. If container is a dict all\nenrichment queries are made at once.",
            "adata": "AnnData object whose group will be looked for.",
            "group": "The group whose genes should be used for enrichment.",
            "key": "Key in uns to find group under.",
            "org str (default: 'hsapiens')": "Organism to query. Must be an organism in ensembl biomart. \u201chsapiens\u201d,\n\u201cmmusculus\u201d, \u201cdrerio\u201d, etc.",
            "gprofiler_kwargs MappingMapping[str, Any] (default: mappingproxy({}))": "Keyword arguments to pass to GProfiler.profile, see gprofiler. Some\nuseful options are no_evidences=False which reports gene intersections,\nsources=['GO:BP'] which limits gene sets to only GO biological processes and\nall_results=True which returns all results including the non-significant ones.",
            "**kwargs": "All other keyword arguments are passed to sc.get.rank_genes_groups_df. E.g.\npval_cutoff, log2fc_min."
        },
        "Return type": "DataFrame",
        "Returns": "Dataframe of enrichment results.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.metrics.confusion_matrix.html": {
        "function_name": "scanpy.metrics.confusion_matrix(orig, new, data=None, *, normalize=True)",
        "description": "Given an original and new set of labels, create a labelled confusion matrix.\nParameters orig and new can either be entries in data or categorical arrays\nof the same size.\nExamples",
        "Parameters": {
            "orig Series | ndarray | SequenceUnion[Series, ndarray, Sequence]": "Original labels.",
            "new Series | ndarray | SequenceUnion[Series, ndarray, Sequence]": "New labels.",
            "data DataFrame | NoneOptional[DataFrame] (default: None)": "Optional dataframe to fill entries from.",
            "normalize bool (default: True)": "Should the confusion matrix be normalized?"
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.metrics.gearys_c.html": {
        "function_name": "scanpy.metrics.gearys_c(adata, *, vals=None, use_graph=None, layer=None, obsm=None, obsp=None, use_raw=False)",
        "description": "Calculate Geary\u2019s C, as used\nby VISION.\nGeary\u2019s C is a measure of autocorrelation for some measure on a graph. This\ncan be to whether measures are correlated between neighboring cells. Lower\nvalues indicate greater correlation.\nThis function can also be called on the graph and values directly. In this case\nthe signature looks like:\nSee the examples for more info.\nExamples\nCalculate Gearys C for each components of a dimensionality reduction:\nIt\u2019s equivalent to call the function directly on the underlying arrays:",
        "Parameters": {
            "adata AnnData": "",
            "vals ndarray | spmatrix | NoneUnion[ndarray, spmatrix, None] (default: None)": "Values to calculate Geary\u2019s C for. If this is two dimensional, should\nbe of shape (n_features, n_cells). Otherwise should be of shape\n(n_cells,). This matrix can be selected from elements of the anndata\nobject by using key word arguments: layer, obsm, obsp, or\nuse_raw.",
            "use_graph str | NoneOptional[str] (default: None)": "Key to use for graph in anndata object. If not provided, default\nneighbors connectivities will be used instead.",
            "layer str | NoneOptional[str] (default: None)": "Key for adata.layers to choose vals.",
            "obsm str | NoneOptional[str] (default: None)": "Key for adata.obsm to choose vals.",
            "obsp str | NoneOptional[str] (default: None)": "Key for adata.obsp to choose vals.",
            "use_raw bool (default: False)": "Whether to use adata.raw.X for vals."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.metrics.morans_i.html": {
        "function_name": "scanpy.metrics.morans_i(adata, *, vals=None, use_graph=None, layer=None, obsm=None, obsp=None, use_raw=False)",
        "description": "Calculate Moran\u2019s I Global Autocorrelation Statistic.\nMoran\u2019s I is a global autocorrelation statistic for some measure on a graph. It is commonly used in\nspatial data analysis to assess autocorrelation on a 2D grid. It is closely related to Geary\u2019s C,\nbut not identical. More info can be found here.\nThis function can also be called on the graph and values directly. In this case\nthe signature looks like:\nSee the examples for more info.\nExamples\nCalculate Morans I for each components of a dimensionality reduction:\nIt\u2019s equivalent to call the function directly on the underlying arrays:",
        "Parameters": {
            "adata AnnData": "",
            "vals ndarray | spmatrix | NoneUnion[ndarray, spmatrix, None] (default: None)": "Values to calculate Moran\u2019s I for. If this is two dimensional, should\nbe of shape (n_features, n_cells). Otherwise should be of shape\n(n_cells,). This matrix can be selected from elements of the anndata\nobject by using key word arguments: layer, obsm, obsp, or\nuse_raw.",
            "use_graph str | NoneOptional[str] (default: None)": "Key to use for graph in anndata object. If not provided, default\nneighbors connectivities will be used instead.",
            "layer str | NoneOptional[str] (default: None)": "Key for adata.layers to choose vals.",
            "obsm str | NoneOptional[str] (default: None)": "Key for adata.obsm to choose vals.",
            "obsp str | NoneOptional[str] (default: None)": "Key for adata.obsp to choose vals.",
            "use_raw bool (default: False)": "Whether to use adata.raw.X for vals."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.experimental.pp.normalize_pearson_residuals.html": {
        "function_name": "scanpy.experimental.pp.normalize_pearson_residuals(adata, *, theta=100, clip=None, check_values=True, layer=None, inplace=True, copy=False)",
        "description": "Applies analytic Pearson residual normalization, based on [Lause21].\nThe residuals are based on a negative binomial offset model with overdispersion\ntheta shared across genes. By default, residuals are clipped to sqrt(n_obs)\nand overdispersion theta=100 is used.\nExpects raw count input.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "theta float (default: 100)": "The negative binomial overdispersion parameter theta for Pearson residuals.\nHigher values correspond to less overdispersion     (var = mean + mean^2/theta), and theta=np.Inf corresponds to a Poisson model.",
            "clip float | NoneOptional[float] (default: None)": "Determines if and how residuals are clipped:\n\nIf None, residuals are clipped to the interval     [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).\nIf any scalar c, residuals are clipped to the interval [-c, c]. Set     clip=np.Inf for no clipping.",
            "check_values bool (default: True)": "If True, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to False can speed up code for large datasets.",
            "layer str | NoneOptional[str] (default: None)": "Layer to use as input instead of X. If None, X is used.",
            "inplace bool (default: True)": "If True, update adata with results. Otherwise, return results. See below for\ndetails of what is returned.",
            "copy bool (default: False)": "If True, the function runs on a copy of the input object and returns the\nmodified copy. Otherwise, the input object is modified direcly. Not compatible\nwith inplace=False."
        },
        "Return type": "{str: ndarray} | NoneOptional[Dict[str, ndarray]]",
        "Returns": "If inplace=True, adata.X or the selected layer in adata.layers is updated\nwith the normalized values. adata.uns is updated with the following fields.\nIf inplace=False, the same fields are returned as dictionary with the\nnormalized values in results_dict['X'].\n\n.uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta.\n\n.uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter.\n\n.uns['pearson_residuals_normalization']['computed_on']The name of the layer on which the residuals were computed.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html": {
        "function_name": "scanpy.experimental.pp.normalize_pearson_residuals_pca(adata, *, theta=100, clip=None, n_comps=50, random_state=0, kwargs_pca={}, use_highly_variable=None, check_values=True, inplace=True)",
        "description": "Applies analytic Pearson residual normalization and PCA, based on [Lause21].\nThe residuals are based on a negative binomial offset model with overdispersion\ntheta shared across genes. By default, residuals are clipped to sqrt(n_obs),\noverdispersion theta=100 is used, and PCA is run with 50 components.\nOperates on the subset of highly variable genes in adata.var['highly_variable']\nby default. Expects raw count input.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "theta float (default: 100)": "The negative binomial overdispersion parameter theta for Pearson residuals.\nHigher values correspond to less overdispersion     (var = mean + mean^2/theta), and theta=np.Inf corresponds to a Poisson model.",
            "clip float | NoneOptional[float] (default: None)": "Determines if and how residuals are clipped:\n\nIf None, residuals are clipped to the interval     [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).\nIf any scalar c, residuals are clipped to the interval [-c, c]. Set     clip=np.Inf for no clipping.",
            "n_comps int | NoneOptional[int] (default: 50)": "Number of principal components to compute in the PCA step.",
            "random_state float | NoneOptional[float] (default: 0)": "Random seed for setting the initial states for the optimization in the PCA step.",
            "kwargs_pca dict | NoneOptional[dict] (default: {})": "Dictionary of further keyword arguments passed on to scanpy.pp.pca().",
            "use_highly_variable bool | NoneOptional[bool] (default: None)": "If True, uses gene selection present in adata.var['highly_variable'] to\nsubset the data before normalizing (default). Otherwise, proceed on the full\ndataset.",
            "check_values bool (default: True)": "If True, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to False can speed up code for large datasets.",
            "inplace bool (default: True)": "If True, update adata with results. Otherwise, return results. See below for\ndetails of what is returned."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "If inplace=False, returns the Pearson residual-based PCA results (as AnnData\nobject). If inplace=True, updates adata with the following fields:\n\n.uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals.\n\n.uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta.\n\n.uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter.\n\n.obsm['X_pca']PCA representation of data after gene selection (if applicable) and Pearson\nresidual normalization.\n\n.varm['PCs']The principal components containing the loadings. When inplace=True and\nuse_highly_variable=True, this will contain empty rows for the genes not\nselected.\n\n.uns['pca']['variance_ratio']Ratio of explained variance.\n\n.uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.experimental.pp.highly_variable_genes.html": {
        "function_name": "scanpy.experimental.pp.highly_variable_genes(adata, *, theta=100, clip=None, n_top_genes=None, batch_key=None, chunksize=1000, flavor='pearson_residuals', check_values=True, layer=None, subset=False, inplace=True)",
        "description": "Select highly variable genes using analytic Pearson residuals [Lause21].\nIn [Lause21], Pearson residuals of a negative binomial offset model are computed\n(with overdispersion theta shared across genes). By default, overdispersion\ntheta=100 is used and residuals are clipped to sqrt(n_obs). Finally, genes\nare ranked by residual variance.\nExpects raw count input.\nNotes\nExperimental version of sc.pp.highly_variable_genes()",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "theta float (default: 100)": "The negative binomial overdispersion parameter theta for Pearson residuals.\nHigher values correspond to less overdispersion     (var = mean + mean^2/theta), and theta=np.Inf corresponds to a Poisson model.",
            "clip float | NoneOptional[float] (default: None)": "Determines if and how residuals are clipped:\n\nIf None, residuals are clipped to the interval     [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).\nIf any scalar c, residuals are clipped to the interval [-c, c]. Set     clip=np.Inf for no clipping.",
            "n_top_genes int | NoneOptional[int] (default: None)": "Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or\nflavor='pearson_residuals'.",
            "batch_key str | NoneOptional[str] (default: None)": "If specified, highly-variable genes are selected within each batch separately\nand merged. This simple process avoids the selection of batch-specific genes\nand acts as a lightweight batch correction method. Genes are first sorted by\nhow many batches they are a HVG. If flavor='pearson_residuals', ties are\nbroken by the median rank (across batches) based on within-batch residual\nvariance.",
            "chunksize int (default: 1000)": "If flavor='pearson_residuals', this dertermines how many genes are processed at\nonce while computing the residual variance. Choosing a smaller value will reduce\nthe required memory.",
            "flavor {\u2018pearson_residuals\u2019}Literal[\u2018pearson_residuals\u2019] (default: 'pearson_residuals')": "Choose the flavor for identifying highly variable genes. In this experimental\nversion, only \u2018pearson_residuals\u2019 is functional.",
            "check_values bool (default: True)": "If True, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to False can speed up code for large datasets.",
            "layer str | NoneOptional[str] (default: None)": "Layer to use as input instead of X. If None, X is used.",
            "subset bool (default: False)": "If True, subset the data to highly-variable genes after finding them.\nOtherwise merely indicate highly variable genes in adata.var (see below).",
            "inplace bool (default: True)": "If True, update adata with results. Otherwise, return results. See below for\ndetails of what is returned."
        },
        "Return type": "DataFrame | NoneOptional[DataFrame]",
        "Returns": "If inplace=True, adata.var is updated with the following fields. Otherwise,\nreturns the same fields as DataFrame.\n\nhighly_variableboolboolean indicator of highly-variable genes.\n\nmeansfloatmeans per gene.\n\nvariancesfloatvariance per gene.\n\nresidual_variancesfloatFor flavor='pearson_residuals', residual variance per gene. Averaged in the\ncase of multiple batches.\n\nhighly_variable_rankfloatFor flavor='pearson_residuals', rank of the gene according to residual.\nvariance, median rank in the case of multiple batches.\n\nhighly_variable_nbatchesintIf batch_key given, denotes in how many batches genes are detected as HVG.\n\nhighly_variable_intersectionboolIf batch_key given, denotes the genes that are highly variable in all batches.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.experimental.pp.recipe_pearson_residuals.html": {
        "function_name": "scanpy.experimental.pp.recipe_pearson_residuals(adata, *, theta=100, clip=None, n_top_genes=1000, batch_key=None, chunksize=1000, n_comps=50, random_state=0, kwargs_pca={}, check_values=True, inplace=True)",
        "description": "Full pipeline for HVG selection and normalization by analytic Pearson residuals ([Lause21]).\nApplies gene selection based on Pearson residuals. On the resulting subset,\nPearson residual normalization and PCA are performed.\nExpects raw count input.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "theta float (default: 100)": "The negative binomial overdispersion parameter theta for Pearson residuals.\nHigher values correspond to less overdispersion     (var = mean + mean^2/theta), and theta=np.Inf corresponds to a Poisson model.",
            "clip float | NoneOptional[float] (default: None)": "Determines if and how residuals are clipped:\n\nIf None, residuals are clipped to the interval     [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).\nIf any scalar c, residuals are clipped to the interval [-c, c]. Set     clip=np.Inf for no clipping.",
            "n_top_genes int (default: 1000)": "Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or\nflavor='pearson_residuals'.",
            "batch_key str | NoneOptional[str] (default: None)": "If specified, highly-variable genes are selected within each batch separately\nand merged. This simple process avoids the selection of batch-specific genes\nand acts as a lightweight batch correction method. Genes are first sorted by\nhow many batches they are a HVG. If flavor='pearson_residuals', ties are\nbroken by the median rank (across batches) based on within-batch residual\nvariance.",
            "chunksize int (default: 1000)": "If flavor='pearson_residuals', this dertermines how many genes are processed at\nonce while computing the residual variance. Choosing a smaller value will reduce\nthe required memory.",
            "n_comps int | NoneOptional[int] (default: 50)": "Number of principal components to compute in the PCA step.",
            "random_state float | NoneOptional[float] (default: 0)": "Random seed for setting the initial states for the optimization in the PCA step.",
            "kwargs_pca dict (default: {})": "Dictionary of further keyword arguments passed on to scanpy.pp.pca().",
            "check_values bool (default: True)": "If True, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to False can speed up code for large datasets.",
            "inplace bool (default: True)": "If True, update adata with results. Otherwise, return results. See below for\ndetails of what is returned."
        },
        "Return type": "Tuple[AnnData, DataFrame] | NoneOptional[Tuple[AnnData, DataFrame]]",
        "Returns": "If inplace=False, separately returns the gene selection results (as\nDataFrame) and Pearson residual-based PCA results (as\nAnnData). If inplace=True, updates adata with the\nfollowing fields for gene selection results:\n\n.var['highly_variable']boolboolean indicator of highly-variable genes.\n\n.var['means']floatmeans per gene.\n\n.var['variances']floatvariances per gene.\n\n.var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple\nbatches.\n\n.var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the\ncase of multiple batches.\n\n.var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are\ndetected as HVG.\n\n.var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable\nin all batches.\n\n\nThe following fields contain Pearson residual-based PCA results and\nnormalization settings:\n\n.uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals.\n\n.uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta.\n\n.uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter.\n\n.obsm['X_pca']PCA representation of data after gene selection and Pearson residual\nnormalization.\n\n.varm['PCs']The principal components containing the loadings. When inplace=True this\nwill contain empty rows for the genes not selected during HVG selection.\n\n.uns['pca']['variance_ratio']Ratio of explained variance.\n\n.uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.connectivities.html": {
        "function_name": "property Neighbors.connectivities: Optional[Union[numpy.ndarray, scipy.sparse._csr.csr_matrix]]",
        "description": "Connectivities between data points (sparse matrix).",
        "Parameters": {},
        "Return type": "ndarray | csr_matrix | NoneUnion[ndarray, csr_matrix, None]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.distances.html": {
        "function_name": "property Neighbors.distances: Optional[Union[numpy.ndarray, scipy.sparse._csr.csr_matrix]]",
        "description": "Distances between data points (sparse matrix).",
        "Parameters": {},
        "Return type": "ndarray | csr_matrix | NoneUnion[ndarray, csr_matrix, None]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.distances_dpt.html": {
        "function_name": "property Neighbors.distances_dpt: scanpy.neighbors.OnFlySymMatrix",
        "description": "DPT distances.\nThis is yields [Haghverdi16], Eq. 15 from the supplement with the\nextensions of [Wolf19], supplement on random-walk based distance\nmeasures.",
        "Parameters": {},
        "Return type": "OnFlySymMatrix"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.eigen_basis.html": {
        "function_name": "property Neighbors.eigen_basis: numpy.ndarray",
        "description": "Eigen basis of transition matrix.",
        "Parameters": {},
        "Return type": "ndarray"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.eigen_values.html": {
        "function_name": "property Neighbors.eigen_values: numpy.ndarray",
        "description": "Eigen values of transition matrix.",
        "Parameters": {},
        "Return type": "ndarray"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.rp_forest.html": {
        "function_name": "property Neighbors.rp_forest: Optional[collections.abc.Mapping[str, collections.abc.Mapping[str, numpy.ndarray]]]",
        "description": "Mapping | NoneOptional[Mapping[str, Mapping[str, ndarray]]]",
        "Parameters": {},
        "Return type": "Mapping | NoneOptional[Mapping[str, Mapping[str, ndarray]]]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.transitions.html": {
        "function_name": "property Neighbors.transitions: Union[numpy.ndarray, scipy.sparse._csr.csr_matrix]",
        "description": "Transition matrix (sparse matrix).\nIs conjugate to the symmetrized transition matrix via:\nwhere self.Z is the diagonal matrix storing the normalization of the\nunderlying kernel matrix.\nNotes\nThis has not been tested, in contrast to transitions_sym.",
        "Parameters": {},
        "Return type": "ndarray | csr_matrixUnion[ndarray, csr_matrix]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.transitions_sym.html": {
        "function_name": "property Neighbors.transitions_sym: Optional[Union[numpy.ndarray, scipy.sparse._csr.csr_matrix]]",
        "description": "Symmetrized transition matrix (sparse matrix).\nIs conjugate to the transition matrix via:\nwhere self.Z is the diagonal matrix storing the normalization of the\nunderlying kernel matrix.",
        "Parameters": {},
        "Return type": "ndarray | csr_matrix | NoneUnion[ndarray, csr_matrix, None]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.compute_eigen.html": {
        "function_name": "Neighbors.compute_eigen(n_comps=15, sym=None, sort='decrease', random_state=0)",
        "description": "Compute eigen decomposition of transition matrix.",
        "Parameters": {
            "n_comps int (default: 15)": "Number of eigenvalues/vectors to be computed, set n_comps = 0 if\nyou need all eigenvectors.",
            "sym bool | NoneOptional[bool] (default: None)": "Instead of computing the eigendecomposition of the assymetric\ntransition matrix, computed the eigendecomposition of the symmetric\nKtilde matrix.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "A numpy random seed"
        },
        "Returns": "Writes the following attributes.\n\neigen_valuesndarrayEigenvalues of transition matrix.\n\neigen_basisndarrayMatrix of eigenvectors (stored in columns).  .eigen_basis is\nprojection of data matrix on right eigenvectors, that is, the\nprojection on the diffusion components.  these are simply the\ncomponents of the right eigenvectors and can directly be used for\nplotting.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.compute_neighbors.html": {
        "function_name": "Neighbors.compute_neighbors(n_neighbors=30, n_pcs=None, *, use_rep=None, knn=True, method='umap', transformer=None, metric='euclidean', metric_kwds=mappingproxy({}), random_state=0)",
        "description": "Compute distances and connectivities of neighbors.",
        "Parameters": {
            "n_neighbors int (default: 30)": "Use this number of nearest neighbors.",
            "n_pcs int | NoneOptional[int] (default: None)": "Use this many PCs. If n_pcs==0 use .X if use_rep is None.",
            "use_rep str | NoneOptional[str] (default: None)": "Use the indicated representation. 'X' or any key for .obsm is valid.\nIf None, the representation is chosen automatically:\nFor .n_vars < N_PCS (default: 50), .X is used, otherwise \u2018X_pca\u2019 is used.\nIf \u2018X_pca\u2019 is not present, it\u2019s computed with default parameters or n_pcs if present.",
            "knn bool (default: True)": "Restrict result to n_neighbors nearest neighbors."
        },
        "Return type": "None",
        "Returns": "Writes sparse graph attributes .distances and .connectivities.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.compute_transitions.html": {
        "function_name": "Neighbors.compute_transitions(density_normalize=True)",
        "description": "Compute transition matrix.",
        "Parameters": {
            "density_normalize bool (default: True)": "The density rescaling of Coifman and Lafon (2006): Then only the\ngeometry of the data matters, not the sampled density."
        },
        "Returns": "Makes attributes .transitions_sym and .transitions available.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.getdoc.html": {
        "function_name": "Neighbors.getdoc() \u2192 Optional[str]",
        "description": "previous\nscanpy.Neighbors.compute_transitions",
        "Parameters": {}
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.Neighbors.to_igraph.html": {
        "function_name": "Neighbors.to_igraph()",
        "description": "Generate igraph from connectiviies.",
        "Parameters": {},
        "Return type": "Graph"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.set_figure_params.html": {
        "function_name": "scanpy.set_figure_params(scanpy=True, dpi=80, dpi_save=150, frameon=True, vector_friendly=True, fontsize=14, figsize=None, color_map=None, format='pdf', facecolor=None, transparent=False, ipython_format='png2x')",
        "description": "Set resolution/size, styling and format of figures.",
        "Parameters": {
            "scanpy bool (default: True)": "Init default values for matplotlib.rcParams suited for Scanpy.",
            "dpi int (default: 80)": "Resolution of rendered figures \u2013 this influences the size of figures in notebooks.",
            "dpi_save int (default: 150)": "Resolution of saved figures. This should typically be higher to achieve\npublication quality.",
            "frameon bool (default: True)": "Add frames and axes labels to scatter plots.",
            "vector_friendly bool (default: True)": "Plot scatter plots using png backend even when exporting as pdf or svg.",
            "fontsize int (default: 14)": "Set the fontsize for several rcParams entries. Ignored if scanpy=False.",
            "figsize int | NoneOptional[int] (default: None)": "Set plt.rcParams[\u2018figure.figsize\u2019].",
            "color_map str | NoneOptional[str] (default: None)": "Convenience method for setting the default color map. Ignored if scanpy=False.",
            "format {\u2018png\u2019, \u2018jpg\u2019, \u2018tif\u2019, \u2018tiff\u2019, \u2018pdf\u2019, \u2018ps\u2019, \u2018eps\u2019, \u2018svg\u2019, \u2018svgz\u2019, \u2018pgf\u2019, \u2018raw\u2019, \u2018rgba\u2019}Literal[\u2018png\u2019, \u2018jpg\u2019, \u2018tif\u2019, \u2018tiff\u2019, \u2018pdf\u2019, \u2018ps\u2019, \u2018eps\u2019, \u2018svg\u2019, \u2018svgz\u2019, \u2018pgf\u2019, \u2018raw\u2019, \u2018rgba\u2019] (default: 'pdf')": "This sets the default format for saving figures: file_format_figs.",
            "facecolor str | NoneOptional[str] (default: None)": "Sets backgrounds via rcParams['figure.facecolor'] = facecolor and\nrcParams['axes.facecolor'] = facecolor.",
            "transparent bool (default: False)": "Save figures with transparent back ground. Sets\nrcParams['savefig.transparent'].",
            "ipython_format str (default: 'png2x')": "Only concerns the notebook/IPython environment; see\nset_matplotlib_formats() for details."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.autosave.html": {
        "function_name": "property ScanpyConfig.autosave: bool",
        "description": "Automatically save figures in figdir (default False).\nDo not show plots/figures interactively.",
        "Parameters": {},
        "Return type": "bool"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.autoshow.html": {
        "function_name": "property ScanpyConfig.autoshow: bool",
        "description": "Automatically show figures if autosave == False (default True).\nThere is no need to call the matplotlib pl.show() in this case.",
        "Parameters": {},
        "Return type": "bool"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.cache_compression.html": {
        "function_name": "property ScanpyConfig.cache_compression: Optional[str]",
        "description": "Compression for sc.read(..., cache=True) (default 'lzf').\nMay be 'lzf', 'gzip', or None.",
        "Parameters": {},
        "Return type": "str | NoneOptional[str]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.cachedir.html": {
        "function_name": "property ScanpyConfig.cachedir: pathlib.Path",
        "description": "Directory for cache files (default './cache/').",
        "Parameters": {},
        "Return type": "Path"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.categories_to_ignore.html": {
        "function_name": "property ScanpyConfig.categories_to_ignore: List[str]",
        "description": "Categories that are omitted in plotting etc.",
        "Parameters": {},
        "Return type": "List[str]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.datasetdir.html": {
        "function_name": "property ScanpyConfig.datasetdir: pathlib.Path",
        "description": "Directory for example datasets (default './data/').",
        "Parameters": {},
        "Return type": "Path"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.figdir.html": {
        "function_name": "property ScanpyConfig.figdir: pathlib.Path",
        "description": "Directory for saving figures (default './figures/').",
        "Parameters": {},
        "Return type": "Path"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.file_format_data.html": {
        "function_name": "property ScanpyConfig.file_format_data: str",
        "description": "File format for saving AnnData objects.\nAllowed are \u2018txt\u2019, \u2018csv\u2019 (comma separated value file) for exporting and \u2018h5ad\u2019\n(hdf5) for lossless saving.",
        "Parameters": {},
        "Return type": "str"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.file_format_figs.html": {
        "function_name": "property ScanpyConfig.file_format_figs: str",
        "description": "File format for saving figures.\nFor example \u2018png\u2019, \u2018pdf\u2019 or \u2018svg\u2019. Many other formats work as well (see\nmatplotlib.pyplot.savefig).",
        "Parameters": {},
        "Return type": "str"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.logfile.html": {
        "function_name": "property ScanpyConfig.logfile: TextIO",
        "description": "The open file to write logs to.\nSet it to a Path or str to open a new one.\nThe default None corresponds to sys.stdout in jupyter notebooks\nand to sys.stderr otherwise.\nFor backwards compatibility, setting it to '' behaves like setting it to None.",
        "Parameters": {},
        "Return type": "TextIO"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.logpath.html": {
        "function_name": "property ScanpyConfig.logpath: Optional[pathlib.Path]",
        "description": "The file path logfile was set to.",
        "Parameters": {},
        "Return type": "Path | NoneOptional[Path]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.max_memory.html": {
        "function_name": "property ScanpyConfig.max_memory: Union[int, float]",
        "description": "Maximum memory usage in Gigabyte.\nIs currently not well respected\u2026",
        "Parameters": {},
        "Return type": "int | floatUnion[int, float]"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.n_jobs.html": {
        "function_name": "property ScanpyConfig.n_jobs: int",
        "description": "Default number of jobs/ CPUs to use for parallel computing.\nSet to -1 in order to use all available cores.\nNot all algorithms support special behavior for numbers < -1,\nso make sure to leave this setting as >= -1.",
        "Parameters": {},
        "Return type": "int"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.plot_suffix.html": {
        "function_name": "property ScanpyConfig.plot_suffix: str",
        "description": "Global suffix that is appended to figure filenames.",
        "Parameters": {},
        "Return type": "str"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.verbosity.html": {
        "function_name": "property ScanpyConfig.verbosity: scanpy._settings.Verbosity",
        "description": "Verbosity level (default warning)\nLevel 0: only show \u2018error\u2019 messages.\nLevel 1: also show \u2018warning\u2019 messages.\nLevel 2: also show \u2018info\u2019 messages.\nLevel 3: also show \u2018hint\u2019 messages.\nLevel 4: also show very detailed progress for \u2018debug\u2019ging.",
        "Parameters": {},
        "Return type": "Verbosity"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.writedir.html": {
        "function_name": "property ScanpyConfig.writedir: pathlib.Path",
        "description": "Directory where the function scanpy.write writes to by default.",
        "Parameters": {},
        "Return type": "Path"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.N_PCS.html": {
        "function_name": "ScanpyConfig.N_PCS: int",
        "description": "Default number of principal components to use.",
        "Parameters": {}
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy._settings.ScanpyConfig.set_figure_params.html": {
        "function_name": "ScanpyConfig.set_figure_params(scanpy=True, dpi=80, dpi_save=150, frameon=True, vector_friendly=True, fontsize=14, figsize=None, color_map=None, format='pdf', facecolor=None, transparent=False, ipython_format='png2x')",
        "description": "Set resolution/size, styling and format of figures.",
        "Parameters": {
            "scanpy bool (default: True)": "Init default values for matplotlib.rcParams suited for Scanpy.",
            "dpi int (default: 80)": "Resolution of rendered figures \u2013 this influences the size of figures in notebooks.",
            "dpi_save int (default: 150)": "Resolution of saved figures. This should typically be higher to achieve\npublication quality.",
            "frameon bool (default: True)": "Add frames and axes labels to scatter plots.",
            "vector_friendly bool (default: True)": "Plot scatter plots using png backend even when exporting as pdf or svg.",
            "fontsize int (default: 14)": "Set the fontsize for several rcParams entries. Ignored if scanpy=False.",
            "figsize int | NoneOptional[int] (default: None)": "Set plt.rcParams[\u2018figure.figsize\u2019].",
            "color_map str | NoneOptional[str] (default: None)": "Convenience method for setting the default color map. Ignored if scanpy=False.",
            "format {\u2018png\u2019, \u2018jpg\u2019, \u2018tif\u2019, \u2018tiff\u2019, \u2018pdf\u2019, \u2018ps\u2019, \u2018eps\u2019, \u2018svg\u2019, \u2018svgz\u2019, \u2018pgf\u2019, \u2018raw\u2019, \u2018rgba\u2019}Literal[\u2018png\u2019, \u2018jpg\u2019, \u2018tif\u2019, \u2018tiff\u2019, \u2018pdf\u2019, \u2018ps\u2019, \u2018eps\u2019, \u2018svg\u2019, \u2018svgz\u2019, \u2018pgf\u2019, \u2018raw\u2019, \u2018rgba\u2019] (default: 'pdf')": "This sets the default format for saving figures: file_format_figs.",
            "facecolor str | NoneOptional[str] (default: None)": "Sets backgrounds via rcParams['figure.facecolor'] = facecolor and\nrcParams['axes.facecolor'] = facecolor.",
            "transparent bool (default: False)": "Save figures with transparent back ground. Sets\nrcParams['savefig.transparent'].",
            "ipython_format str (default: 'png2x')": "Only concerns the notebook/IPython environment; see\nset_matplotlib_formats() for details."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.logging.print_header.html": {
        "function_name": "scanpy.logging.print_header(*, file=None)",
        "description": "Versions that might influence the numerical results.\nMatplotlib and Seaborn are excluded from this.",
        "Parameters": {}
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.logging.print_versions.html": {
        "function_name": "scanpy.logging.print_versions(*, file=None)",
        "description": "Print versions of imported packages, OS, and jupyter environment.\nFor more options (including rich output) use session_info.show directly.",
        "Parameters": {}
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.blobs.html": {
        "function_name": "scanpy.datasets.blobs(n_variables=11, n_centers=5, cluster_std=1.0, n_observations=640)",
        "description": "Gaussian Blobs.",
        "Parameters": {
            "n_variables int (default: 11)": "Dimension of feature space.",
            "n_centers int (default: 5)": "Number of cluster centers.",
            "cluster_std float (default: 1.0)": "Standard deviation of clusters.",
            "n_observations int (default: 640)": "Number of observations. By default, this is the same observation number\nas in scanpy.datasets.krumsiek11()."
        },
        "Return type": "AnnData",
        "Returns": "Annotated data matrix containing a observation annotation \u2018blobs\u2019 that\nindicates cluster identity.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.ebi_expression_atlas.html": {
        "function_name": "scanpy.datasets.ebi_expression_atlas(accession, *, filter_boring=False)",
        "description": "Load a dataset from the EBI Single Cell Expression Atlas\nDownloaded datasets are saved in the directory specified by\ndatasetdir.\nExample",
        "Parameters": {
            "accession str": "Dataset accession. Like E-GEOD-98816 or E-MTAB-4888.\nThis can be found in the url on the datasets page, for example\nhttps://www.ebi.ac.uk/gxa/sc/experiments/E-GEOD-98816/results/tsne.",
            "filter_boring bool (default: False)": "Whether boring labels in .obs should be automatically removed, such as\nlabels with a single or n_obs distinct values."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.krumsiek11.html": {
        "function_name": "scanpy.datasets.krumsiek11()",
        "description": "Simulated myeloid progenitors [Krumsiek11].\nThe literature-curated boolean network from [Krumsiek11] was used to\nsimulate the data. It describes development to four cell fates: \u2018monocyte\u2019,\n\u2018erythrocyte\u2019, \u2018megakaryocyte\u2019 and \u2018neutrophil\u2019.\nSee also the discussion of this data in [Wolf19].\nSimulate via sim().",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.moignard15.html": {
        "function_name": "scanpy.datasets.moignard15()",
        "description": "Hematopoiesis in early mouse embryos [Moignard15].",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.pbmc3k.html": {
        "function_name": "scanpy.datasets.pbmc3k()",
        "description": "3k PBMCs from 10x Genomics.\nThe data consists in 3k PBMCs from a Healthy Donor and is freely available\nfrom 10x Genomics (here\nfrom this webpage).\nThe exact same data is also used in Seurat\u2019s\nbasic clustering tutorial.\nThe following code was run to produce the file.",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.pbmc3k_processed.html": {
        "function_name": "scanpy.datasets.pbmc3k_processed()",
        "description": "Processed 3k PBMCs from 10x Genomics.\nProcessed using the basic tutorial Preprocessing and clustering 3k PBMCs.",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.pbmc68k_reduced.html": {
        "function_name": "scanpy.datasets.pbmc68k_reduced()",
        "description": "Subsampled and processed 68k PBMCs.\n10x PBMC 68k dataset from\nhttps://support.10xgenomics.com/single-cell-gene-expression/datasets\nThe original PBMC 68k dataset was preprocessed using scanpy and was saved\nkeeping only 724 cells and 221 highly variable genes.\nThe saved file contains the annotation of cell types (key: 'bulk_labels'),\nUMAP coordinates, louvain clustering and gene rankings based on the\nbulk_labels.",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.paul15.html": {
        "function_name": "scanpy.datasets.paul15()",
        "description": "Development of Myeloid Progenitors [Paul15].\nNon-logarithmized raw data.\nThe data has been sent out by Email from the Amit Lab. An R version for\nloading the data can be found here\ntheislab/scAnalysisTutorial",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.toggleswitch.html": {
        "function_name": "scanpy.datasets.toggleswitch()",
        "description": "Simulated toggleswitch.\nData obtained simulating a simple toggleswitch [Gardner00]\nSimulate via sim().",
        "Parameters": {},
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.datasets.visium_sge.html": {
        "function_name": "scanpy.datasets.visium_sge(sample_id='V1_Breast_Cancer_Block_A_Section_1', *, include_hires_tiff=False)",
        "description": "Processed Visium Spatial Gene Expression data from 10x Genomics.\nDatabase: https://support.10xgenomics.com/spatial-gene-expression/datasets",
        "Parameters": {
            "sample_id {\u2018V1_Breast_Cancer_Block_A_Section_1\u2019, \u2018V1_Breast_Cancer_Block_A_Section_2\u2019, \u2018V1_Human_Heart\u2019, \u2018V1_Human_Lymph_Node\u2019, \u2018V1_Mouse_Kidney\u2019, \u2018V1_Adult_Mouse_Brain\u2019, \u2018V1_Mouse_Brain_Sagittal_Posterior\u2019, \u2018V1_Mouse_Brain_Sagittal_Posterior_Section_2\u2019, \u2018V1_Mouse_Brain_Sagittal_Anterior\u2019, \u2018V1_Mouse_Brain_Sagittal_Anterior_Section_2\u2019, \u2018V1_Human_Brain_Section_1\u2019, \u2018V1_Human_Brain_Section_2\u2019, \u2018V1_Adult_Mouse_Brain_Coronal_Section_1\u2019, \u2018V1_Adult_Mouse_Brain_Coronal_Section_2\u2019, \u2018Targeted_Visium_Human_Cerebellum_Neuroscience\u2019, \u2018Parent_Visium_Human_Cerebellum\u2019, \u2018Targeted_Visium_Human_SpinalCord_Neuroscience\u2019, \u2018Parent_Visium_Human_SpinalCord\u2019, \u2018Targeted_Visium_Human_Glioblastoma_Pan_Cancer\u2019, \u2018Parent_Visium_Human_Glioblastoma\u2019, \u2018Targeted_Visium_Human_BreastCancer_Immunology\u2019, \u2018Parent_Visium_Human_BreastCancer\u2019, \u2018Targeted_Visium_Human_OvarianCancer_Pan_Cancer\u2019, \u2018Targeted_Visium_Human_OvarianCancer_Immunology\u2019, \u2018Parent_Visium_Human_OvarianCancer\u2019, \u2018Targeted_Visium_Human_ColorectalCancer_GeneSignature\u2019, \u2018Parent_Visium_Human_ColorectalCancer\u2019}Literal[\u2018V1_Breast_Cancer_Block_A_Section_1\u2019, \u2018V1_Breast_Cancer_Block_A_Section_2\u2019, \u2018V1_Human_Heart\u2019, \u2018V1_Human_Lymph_Node\u2019, \u2018V1_Mouse_Kidney\u2019, \u2018V1_Adult_Mouse_Brain\u2019, \u2018V1_Mouse_Brain_Sagittal_Posterior\u2019, \u2018V1_Mouse_Brain_Sagittal_Posterior_Section_2\u2019, \u2018V1_Mouse_Brain_Sagittal_Anterior\u2019, \u2018V1_Mouse_Brain_Sagittal_Anterior_Section_2\u2019, \u2018V1_Human_Brain_Section_1\u2019, \u2018V1_Human_Brain_Section_2\u2019, \u2018V1_Adult_Mouse_Brain_Coronal_Section_1\u2019, \u2018V1_Adult_Mouse_Brain_Coronal_Section_2\u2019, \u2018Targeted_Visium_Human_Cerebellum_Neuroscience\u2019, \u2018Parent_Visium_Human_Cerebellum\u2019, \u2018Targeted_Visium_Human_SpinalCord_Neuroscience\u2019, \u2018Parent_Visium_Human_SpinalCord\u2019, \u2018Targeted_Visium_Human_Glioblastoma_Pan_Cancer\u2019, \u2018Parent_Visium_Human_Glioblastoma\u2019, \u2018Targeted_Visium_Human_BreastCancer_Immunology\u2019, \u2018Parent_Visium_Human_BreastCancer\u2019, \u2018Targeted_Visium_Human_OvarianCancer_Pan_Cancer\u2019, \u2018Targeted_Visium_Human_OvarianCancer_Immunology\u2019, \u2018Parent_Visium_Human_OvarianCancer\u2019, \u2018Targeted_Visium_Human_ColorectalCancer_GeneSignature\u2019, \u2018Parent_Visium_Human_ColorectalCancer\u2019] (default: 'V1_Breast_Cancer_Block_A_Section_1')": "The ID of the data sample in 10x\u2019s spatial database.",
            "include_hires_tiff bool (default: False)": "Download and include the high-resolution tissue image (tiff) in adata.uns[\"spatial\"][sample_id][\"metadata\"][\"source_image_path\"]."
        },
        "Return type": "AnnData",
        "Returns": "Annotated data matrix.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.filter_genes_dispersion.html": {
        "function_name": "scanpy.pp.filter_genes_dispersion(data, flavor='seurat', min_disp=None, max_disp=None, min_mean=None, max_mean=None, n_bins=20, n_top_genes=None, log=True, subset=True, copy=False)",
        "description": "Extract highly variable genes [Satija15] [Zheng17].\nIf trying out parameters, pass the data matrix instead of AnnData.\nDepending on flavor, this reproduces the R-implementations of Seurat\n[Satija15] and Cell Ranger [Zheng17].\nThe normalized dispersion is obtained by scaling with the mean and standard\ndeviation of the dispersions for genes falling into a given bin for mean\nexpression of genes. This means that for each bin of mean expression, highly\nvariable genes are selected.\nUse flavor='cell_ranger' with care and in the same way as in\nrecipe_zheng17().",
        "Parameters": {
            "data AnnData": "The (annotated) data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes.",
            "flavor {\u2018seurat\u2019, \u2018cell_ranger\u2019}Literal[\u2018seurat\u2019, \u2018cell_ranger\u2019] (default: 'seurat')": "Choose the flavor for computing normalized dispersion. If choosing\n\u2018seurat\u2019, this expects non-logarithmized data \u2013 the logarithm of mean\nand dispersion is taken internally when log is at its default value\nTrue. For \u2018cell_ranger\u2019, this is usually called for logarithmized data\n\u2013 in this case you should set log to False. In their default\nworkflows, Seurat passes the cutoffs whereas Cell Ranger passes\nn_top_genes.",
            "min_mean float | NoneOptional[float] (default: None)": "",
            "max_mean float | NoneOptional[float] (default: None)": "",
            "min_disp float | NoneOptional[float] (default: None)": "",
            "max_disp float | NoneOptional[float] (default: None)": "If n_top_genes unequals None, these cutoffs for the means and the\nnormalized dispersions are ignored.",
            "n_bins int (default: 20)": "Number of bins for binning the mean gene expression. Normalization is\ndone with respect to each bin. If just a single gene falls into a bin,\nthe normalized dispersion is artificially set to 1. You\u2019ll be informed\nabout this if you set settings.verbosity = 4.",
            "n_top_genes int | NoneOptional[int] (default: None)": "Number of highly-variable genes to keep.",
            "log bool (default: True)": "Use the logarithm of the mean to variance ratio.",
            "subset bool (default: True)": "Keep highly-variable genes only (if True) else write a bool array for h\nighly-variable genes while keeping all genes",
            "copy bool (default: False)": "If an AnnData is passed, determines whether a copy\nis returned."
        },
        "Returns": "If an AnnData adata is passed, returns or updates adata depending on\ncopy. It filters the adata and adds the annotations\n\nmeansadata.varMeans per gene. Logarithmized when log is True.\n\ndispersionsadata.varDispersions per gene. Logarithmized when log is True.\n\ndispersions_normadata.varNormalized dispersions per gene. Logarithmized when log is True.\n\n\nIf a data matrix X is passed, the annotation is returned as np.recarray\nwith the same information stored in fields: gene_subset, means, dispersions, dispersion_norm.\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.pp.normalize_per_cell.html": {
        "function_name": "scanpy.pp.normalize_per_cell(data, counts_per_cell_after=None, counts_per_cell=None, key_n_counts='n_counts', copy=False, layers=(), use_rep=None, min_counts=1)",
        "description": "Normalize total counts per cell.\nNormalize each cell by total counts over all genes, so that every cell has\nthe same total count after normalization.\nSimilar functions are used, for example, by Seurat [Satija15], Cell Ranger\n[Zheng17] or SPRING [Weinreb17].\nExamples",
        "Parameters": {
            "data AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "The (annotated) data matrix of shape n_obs \u00d7 n_vars. Rows correspond\nto cells and columns to genes.",
            "counts_per_cell_after float | NoneOptional[float] (default: None)": "If None, after normalization, each cell has a total count equal\nto the median of the counts_per_cell before normalization.",
            "counts_per_cell ndarray | NoneOptional[ndarray] (default: None)": "Precomputed counts per cell.",
            "key_n_counts str (default: 'n_counts')": "Name of the field in adata.obs where the total counts per cell are\nstored.",
            "copy bool (default: False)": "If an AnnData is passed, determines whether a copy\nis returned.",
            "min_counts int (default: 1)": "Cells with counts less than min_counts are filtered out during\nnormalization."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Returns or updates adata with normalized version of the original\nadata.X, depending on copy.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.bbknn.html": {
        "function_name": "scanpy.external.pp.bbknn(adata, batch_key='batch', use_rep='X_pca', approx=True, use_annoy=True, metric='euclidean', copy=False, *, neighbors_within_batch=3, n_pcs=50, trim=None, annoy_n_trees=10, pynndescent_n_neighbors=30, pynndescent_random_state=0, use_faiss=True, set_op_mix_ratio=1.0, local_connectivity=1, **kwargs)",
        "description": "Batch balanced kNN [Polanski19].\nBatch balanced kNN alters the kNN procedure to identify each cell\u2019s top neighbours in\neach batch separately instead of the entire cell pool with no accounting for batch.\nThe nearest neighbours for each batch are then merged to create a final list of\nneighbours for the cell. Aligns batches in a quick and lightweight manner.\nFor use in the scanpy workflow as an alternative to neighbors().",
        "Parameters": {
            "adata": "Needs the PCA computed and stored in adata.obsm[\"X_pca\"].",
            "batch_key": "adata.obs column name discriminating between your batches.",
            "use_rep": "The dimensionality reduction in .obsm to use for neighbour detection. Defaults to PCA.",
            "approx": "If True, use approximate neighbour finding - annoy or pyNNDescent. This results\nin a quicker run time for large datasets while also potentially increasing the degree of\nbatch correction.",
            "use_annoy": "Only used when approx=True. If True, will use annoy for neighbour finding. If\nFalse, will use pyNNDescent instead.",
            "metric": "What distance metric to use. The options depend on the choice of neighbour algorithm.\n\u201deuclidean\u201d, the default, is always available.\nAnnoy supports \u201cangular\u201d, \u201cmanhattan\u201d and \u201chamming\u201d.\nPyNNDescent supports metrics listed in pynndescent.distances.named_distances\nand custom functions, including compiled Numba code.\n>>> pynndescent.distances.named_distances.keys()\ndict_keys(['euclidean', 'l2', 'sqeuclidean', 'manhattan', 'taxicab', 'l1', 'chebyshev', 'linfinity',\n'linfty', 'linf', 'minkowski', 'seuclidean', 'standardised_euclidean', 'wminkowski', 'weighted_minkowski',\n'mahalanobis', 'canberra', 'cosine', 'dot', 'correlation', 'hellinger', 'haversine', 'braycurtis', 'spearmanr',\n'kantorovich', 'wasserstein', 'tsss', 'true_angular', 'hamming', 'jaccard', 'dice', 'matching', 'kulsinski',\n'rogerstanimoto', 'russellrao', 'sokalsneath', 'sokalmichener', 'yule'])\n\n\nKDTree supports members of the sklearn.neighbors.KDTree.valid_metrics list, or parameterised\nsklearn.neighbors.DistanceMetric objects:\n>>> sklearn.neighbors.KDTree.valid_metrics\n['p', 'chebyshev', 'cityblock', 'minkowski', 'infinity', 'l2', 'euclidean', 'manhattan', 'l1']",
            "copy": "If True, return a copy instead of writing to the supplied adata.",
            "neighbors_within_batch": "How many top neighbours to report for each batch; total number of neighbours in\nthe initial k-nearest-neighbours computation will be this number times the number\nof batches. This then serves as the basis for the construction of a symmetrical\nmatrix of connectivities.",
            "n_pcs": "How many dimensions (in case of PCA, principal components) to use in the analysis.",
            "trim": "Trim the neighbours of each cell to these many top connectivities. May help with\npopulation independence and improve the tidiness of clustering. The lower the value the\nmore independent the individual populations, at the cost of more conserved batch effect.\nIf None, sets the parameter value automatically to 10 times neighbors_within_batch\ntimes the number of batches. Set to 0 to skip.",
            "annoy_n_trees": "Only used with annoy neighbour identification. The number of trees to construct in the\nannoy forest. More trees give higher precision when querying, at the cost of increased\nrun time and resource intensity.",
            "pynndescent_n_neighbors": "Only used with pyNNDescent neighbour identification. The number of neighbours to include\nin the approximate neighbour graph. More neighbours give higher precision when querying,\nat the cost of increased run time and resource intensity.",
            "pynndescent_random_state": "Only used with pyNNDescent neighbour identification. The RNG seed to use when creating\nthe graph.",
            "use_faiss": "If approx=False and the metric is \u201ceuclidean\u201d, use the faiss package to compute\nnearest neighbours if installed. This improves performance at a minor cost to numerical\nprecision as faiss operates on float32.",
            "set_op_mix_ratio": "UMAP connectivity computation parameter, float between 0 and 1, controlling the\nblend between a connectivity matrix formed exclusively from mutual nearest neighbour\npairs (0) and a union of all observed neighbour relationships with the mutual pairs\nemphasised (1)",
            "local_connectivity": "UMAP connectivity computation parameter, how many nearest neighbors of each cell\nare assumed to be fully connected (and given a connectivity value of 1)"
        },
        "Returns": "The adata with the batch-corrected graph.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.harmony_integrate.html": {
        "function_name": "scanpy.external.pp.harmony_integrate(adata, key, basis='X_pca', adjusted_basis='X_pca_harmony', **kwargs)",
        "description": "Use harmonypy [Korunsky19] to integrate different experiments.\nHarmony [Korunsky19] is an algorithm for integrating single-cell\ndata from multiple experiments. This function uses the python\nport of Harmony, harmonypy, to integrate single-cell data\nstored in an AnnData object. As Harmony works by adjusting the\nprincipal components, this function should be run after performing\nPCA but before computing the neighbor graph, as illustrated in the\nexample below.\nExample\nFirst, load libraries and example dataset, and preprocess.\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in adata.obs giving the experiment each cell came\nfrom.\nFinally, run harmony. Afterwards, there will be a new table in\nadata.obsm containing the adjusted PC\u2019s.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "key str": "The name of the column in adata.obs that differentiates\namong experiments/batches.",
            "basis str (default: 'X_pca')": "The name of the field in adata.obsm where the PCA table is\nstored. Defaults to 'X_pca', which is the default for\nsc.tl.pca().",
            "adjusted_basis str (default: 'X_pca_harmony')": "The name of the field in adata.obsm where the adjusted PCA\ntable will be stored after running this function. Defaults to\nX_pca_harmony.",
            "kwargs": "Any additional arguments will be passed to\nharmonypy.run_harmony()."
        },
        "Returns": "Updates adata with the field adata.obsm[obsm_out_field],\ncontaining principal components adjusted by Harmony such that\ndifferent experiments are integrated.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.mnn_correct.html": {
        "function_name": "scanpy.external.pp.mnn_correct(*datas, var_index=None, var_subset=None, batch_key='batch', index_unique='-', batch_categories=None, k=20, sigma=1.0, cos_norm_in=True, cos_norm_out=True, svd_dim=None, var_adj=True, compute_angle=False, mnn_order=None, svd_mode='rsvd', do_concatenate=True, save_raw=False, n_jobs=None, **kwargs)",
        "description": "Correct batch effects by matching mutual nearest neighbors [Haghverdi18] [Kang18].\nThis uses the implementation of mnnpy [Kang18].\nDepending on do_concatenate, returns matrices or AnnData objects in the\noriginal order containing corrected expression values or a concatenated\nmatrix or AnnData object.\nBe reminded that it is not advised to use the corrected data matrices for\ndifferential expression testing.\nMore information and bug reports here.",
        "Parameters": {
            "datas AnnData | ndarrayUnion[AnnData, ndarray]": "Expression matrices or AnnData objects. Matrices should be shaped like\nn_obs \u00d7 n_vars (n_cell \u00d7 n_gene) and have consistent number of columns.\nAnnData objects should have same number of variables.",
            "var_index Collection[str] | NoneOptional[Collection[str]] (default: None)": "The index (list of str) of vars (genes). Necessary when using only a\nsubset of vars to perform MNN correction, and should be supplied with\nvar_subset. When datas are AnnData objects, var_index is ignored.",
            "var_subset Collection[str] | NoneOptional[Collection[str]] (default: None)": "The subset of vars (list of str) to be used when performing MNN\ncorrection. Typically, a list of highly variable genes (HVGs).\nWhen set to None, uses all vars.",
            "batch_key str (default: 'batch')": "The batch_key for concatenate().\nOnly valid when do_concatenate and supplying AnnData objects.",
            "index_unique str (default: '-')": "The index_unique for concatenate().\nOnly valid when do_concatenate and supplying AnnData objects.",
            "batch_categories Collection[Any] | NoneOptional[Collection[Any]] (default: None)": "The batch_categories for concatenate().\nOnly valid when do_concatenate and supplying AnnData objects.",
            "k int (default: 20)": "Number of mutual nearest neighbors.",
            "sigma float (default: 1.0)": "The bandwidth of the Gaussian smoothing kernel used to compute the\ncorrection vectors. Default is 1.",
            "cos_norm_in bool (default: True)": "Whether cosine normalization should be performed on the input data prior\nto calculating distances between cells.",
            "cos_norm_out bool (default: True)": "Whether cosine normalization should be performed prior to computing corrected expression values.",
            "svd_dim int | NoneOptional[int] (default: None)": "The number of dimensions to use for summarizing biological substructure\nwithin each batch. If None, biological components will not be removed\nfrom the correction vectors.",
            "var_adj bool (default: True)": "Whether to adjust variance of the correction vectors. Note this step\ntakes most computing time.",
            "compute_angle bool (default: False)": "Whether to compute the angle between each cell\u2019s correction vector and\nthe biological subspace of the reference batch.",
            "mnn_order Sequence[int] | NoneOptional[Sequence[int]] (default: None)": "The order in which batches are to be corrected. When set to None, datas\nare corrected sequentially.",
            "svd_mode {\u2018svd\u2019, \u2018rsvd\u2019, \u2018irlb\u2019}Literal[\u2018svd\u2019, \u2018rsvd\u2019, \u2018irlb\u2019] (default: 'rsvd')": "'svd' computes SVD using a non-randomized SVD-via-ID algorithm,\nwhile 'rsvd' uses a randomized version. 'irlb' perfores\ntruncated SVD by implicitly restarted Lanczos bidiagonalization\n(forked from airysen/irlbpy).",
            "do_concatenate bool (default: True)": "Whether to concatenate the corrected matrices or AnnData objects. Default is True.",
            "save_raw bool (default: False)": "Whether to save the original expression data in the\nraw attribute.",
            "n_jobs int | NoneOptional[int] (default: None)": "The number of jobs. When set to None, automatically uses\nscanpy._settings.ScanpyConfig.n_jobs.",
            "kwargs": "optional keyword arguments for irlb."
        },
        "Return type": "Tuple[Union[ndarray, AnnData], List[DataFrame], Optional[List[Tuple[Optional[float], int]]]]",
        "Returns": "\ndatasndarray | AnnDataUnion[ndarray, AnnData]Corrected matrix/matrices or AnnData object/objects, depending on the\ninput type and do_concatenate.\n\nmnn_listList[DataFrame]A list containing MNN pairing information as DataFrames in each iteration step.\n\nangle_listList[Tuple[Optional[float], int]] | NoneOptional[List[Tuple[Optional[float], int]]]A list containing angles of each batch.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.scanorama_integrate.html": {
        "function_name": "scanpy.external.pp.scanorama_integrate(adata, key, basis='X_pca', adjusted_basis='X_scanorama', knn=20, sigma=15, approx=True, alpha=0.1, batch_size=5000, **kwargs)",
        "description": "Use Scanorama [Hie19] to integrate different experiments.\nScanorama [Hie19] is an algorithm for integrating single-cell\ndata from multiple experiments stored in an AnnData object. This\nfunction should be run after performing PCA but before computing\nthe neighbor graph, as illustrated in the example below.\nThis uses the implementation of scanorama [Hie19].\nExample\nFirst, load libraries and example dataset, and preprocess.\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in adata.obs giving the experiment each cell came\nfrom.\nFinally, run Scanorama. Afterwards, there will be a new table in\nadata.obsm containing the Scanorama embeddings.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "key str": "The name of the column in adata.obs that differentiates\namong experiments/batches. Cells from the same batch must be\ncontiguously stored in adata.",
            "basis str (default: 'X_pca')": "The name of the field in adata.obsm where the PCA table is\nstored. Defaults to 'X_pca', which is the default for\nsc.tl.pca().",
            "adjusted_basis str (default: 'X_scanorama')": "The name of the field in adata.obsm where the integrated\nembeddings will be stored after running this function. Defaults\nto X_scanorama.",
            "knn int (default: 20)": "Number of nearest neighbors to use for matching.",
            "sigma float (default: 15)": "Correction smoothing parameter on Gaussian kernel.",
            "approx bool (default: True)": "Use approximate nearest neighbors with Python annoy;\ngreatly speeds up matching runtime.",
            "alpha float (default: 0.1)": "Alignment score minimum cutoff.",
            "batch_size int (default: 5000)": "The batch size used in the alignment vector computation. Useful\nwhen integrating very large (>100k samples) datasets. Set to\nlarge value that runs within available memory.",
            "kwargs": "Any additional arguments will be passed to\nscanorama.integrate()."
        },
        "Returns": "Updates adata with the field adata.obsm[adjusted_basis],\ncontaining Scanorama embeddings such that different experiments\nare integrated.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.scrublet.html": {
        "function_name": "scanpy.external.pp.scrublet(adata, adata_sim=None, batch_key=None, sim_doublet_ratio=2.0, expected_doublet_rate=0.05, stdev_doublet_rate=0.02, synthetic_doublet_umi_subsampling=1.0, knn_dist_metric='euclidean', normalize_variance=True, log_transform=False, mean_center=True, n_prin_comps=30, use_approx_neighbors=True, get_doublet_neighbor_parents=False, n_neighbors=None, threshold=None, verbose=True, copy=False, random_state=0)",
        "description": "Predict doublets using Scrublet [Wolock19].\nPredict cell doublets using a nearest-neighbor classifier of observed\ntranscriptomes and simulated doublets. Works best if the input is a raw\n(unnormalized) counts matrix from a single sample or a collection of\nsimilar samples from the same experiment.\nThis function is a wrapper around functions that pre-process using Scanpy\nand directly call functions of Scrublet(). You may also undertake your own\npreprocessing, simulate doublets with\nscanpy.external.pp.scrublet_simulate_doublets(), and run the core scrublet\nfunction scanpy.external.pp.scrublet.scrublet().",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars. Rows\ncorrespond to cells and columns to genes. Expected to be un-normalised\nwhere adata_sim is not supplied, in which case doublets will be\nsimulated and pre-processing applied to both objects. If adata_sim is\nsupplied, this should be the observed transcriptomes processed\nconsistently (filtering, transform, normalisaton, hvg) with adata_sim.",
            "adata_sim AnnData | NoneOptional[AnnData] (default: None)": "(Advanced use case) Optional annData object generated by\nsc.external.pp.scrublet_simulate_doublets(), with same number of vars\nas adata. This should have been built from adata_obs after\nfiltering genes and cells and selcting highly-variable genes.",
            "batch_key str (default: None)": "Optional adata.obs column name discriminating between batches.",
            "sim_doublet_ratio float (default: 2.0)": "Number of doublets to simulate relative to the number of observed\ntranscriptomes.",
            "expected_doublet_rate float (default: 0.05)": "Where adata_sim not suplied, the estimated doublet rate for the\nexperiment.",
            "stdev_doublet_rate float (default: 0.02)": "Where adata_sim not suplied, uncertainty in the expected doublet rate.",
            "synthetic_doublet_umi_subsampling float (default: 1.0)": "Where adata_sim not suplied, rate for sampling UMIs when creating\nsynthetic doublets. If 1.0, each doublet is created by simply adding\nthe UMI counts from two randomly sampled observed transcriptomes. For\nvalues less than 1, the UMI counts are added and then randomly sampled\nat the specified rate.",
            "knn_dist_metric str (default: 'euclidean')": "Distance metric used when finding nearest neighbors. For list of\nvalid values, see the documentation for annoy (if use_approx_neighbors\nis True) or sklearn.neighbors.NearestNeighbors (if use_approx_neighbors\nis False).",
            "normalize_variance bool (default: True)": "If True, normalize the data such that each gene has a variance of 1.\nsklearn.decomposition.TruncatedSVD will be used for dimensionality\nreduction, unless mean_center is True.",
            "log_transform bool (default: False)": "Whether to use :func:~scanpy.pp.log1p to log-transform the data\nprior to PCA.",
            "mean_center bool (default: True)": "If True, center the data such that each gene has a mean of 0.\nsklearn.decomposition.PCA will be used for dimensionality\nreduction.",
            "n_prin_comps int (default: 30)": "Number of principal components used to embed the transcriptomes prior\nto k-nearest-neighbor graph construction.",
            "use_approx_neighbors bool (default: True)": "Use approximate nearest neighbor method (annoy) for the KNN\nclassifier.",
            "get_doublet_neighbor_parents bool (default: False)": "If True, return (in .uns) the parent transcriptomes that generated the\ndoublet neighbors of each observed transcriptome. This information can\nbe used to infer the cell states that generated a given doublet state.",
            "n_neighbors int | NoneOptional[int] (default: None)": "Number of neighbors used to construct the KNN graph of observed\ntranscriptomes and simulated doublets. If None, this is\nautomatically set to np.round(0.5 * np.sqrt(n_obs)).",
            "threshold float | NoneOptional[float] (default: None)": "Doublet score threshold for calling a transcriptome a doublet. If\nNone, this is set automatically by looking for the minimum between\nthe two modes of the doublet_scores_sim_ histogram. It is best\npractice to check the threshold visually using the\ndoublet_scores_sim_ histogram and/or based on co-localization of\npredicted doublets in a 2-D embedding.",
            "verbose bool (default: True)": "If True, print progress updates.",
            "copy bool (default: False)": "If True, return a copy of the input adata with Scrublet results\nadded. Otherwise, Scrublet results are added in place.",
            "random_state int (default: 0)": "Initial state for doublet simulation and nearest neighbors."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "adata : AnnData\nif copy=True it returns or else adds fields to adata. Those fields:\n\n.obs['doublet_score']Doublet scores for each observed transcriptome\n\n.obs['predicted_doublet']Boolean indicating predicted doublet status\n\n.uns['scrublet']['doublet_scores_sim']Doublet scores for each simulated doublet transcriptome\n\n.uns['scrublet']['doublet_parents']Pairs of .obs_names used to generate each simulated doublet\ntranscriptome\n\n.uns['scrublet']['parameters']Dictionary of Scrublet parameters\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.scrublet_simulate_doublets.html": {
        "function_name": "scanpy.external.pp.scrublet_simulate_doublets(adata, layer=None, sim_doublet_ratio=2.0, synthetic_doublet_umi_subsampling=1.0, random_seed=0)",
        "description": "Simulate doublets by adding the counts of random observed transcriptome pairs.",
        "Parameters": {
            "adata AnnData": "The annotated data matrix of shape n_obs \u00d7 n_vars. Rows\ncorrespond to cells and columns to genes. Genes should have been\nfiltered for expression and variability, and the object should contain\nraw expression of the same dimensions.",
            "layer": "Layer of adata where raw values are stored, or \u2018X\u2019 if values are in .X.",
            "sim_doublet_ratio float (default: 2.0)": "Number of doublets to simulate relative to the number of observed\ntranscriptomes. If None, self.sim_doublet_ratio is used.",
            "synthetic_doublet_umi_subsampling float (default: 1.0)": "Rate for sampling UMIs when creating synthetic doublets. If 1.0,\neach doublet is created by simply adding the UMIs from two randomly\nsampled observed transcriptomes. For values less than 1, the\nUMI counts are added and then randomly sampled at the specified\nrate."
        },
        "Return type": "AnnData",
        "Returns": "adata : anndata.AnnData with simulated doublets in .X\nAdds fields to adata:\n\n.obsm['scrublet']['doublet_parents']Pairs of .obs_names used to generate each simulated doublet transcriptome\n\n.uns['scrublet']['parameters']Dictionary of Scrublet parameters\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pl.scrublet_score_distribution.html": {
        "function_name": "scanpy.external.pl.scrublet_score_distribution(adata, scale_hist_obs='log', scale_hist_sim='linear', figsize=(8, 3), return_fig=False, show=True, save=None)",
        "description": "Plot histogram of doublet scores for observed transcriptomes and simulated doublets.\nThe histogram for simulated doublets is useful for determining the correct doublet\nscore threshold.\nScrublet must have been run previously with the input object.",
        "Parameters": {
            "adata": "An annData object resulting from func:~scanpy.external.scrublet.",
            "scale_hist_obs str (default: 'log')": "Set y axis scale transformation in matplotlib for the plot of observed\ntranscriptomes (e.g. \u201clinear\u201d, \u201clog\u201d, \u201csymlog\u201d, \u201clogit\u201d)",
            "scale_hist_sim str (default: 'linear')": "Set y axis scale transformation in matplotlib for the plot of simulated\ndoublets (e.g. \u201clinear\u201d, \u201clog\u201d, \u201csymlog\u201d, \u201clogit\u201d)",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: (8, 3))": "width, height",
            "show bool (default: True)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}."
        },
        "Returns": "If return_fig is True, a Figure.\nIf show==False a list of Axes.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.hashsolo.html": {
        "function_name": "scanpy.external.pp.hashsolo(adata, cell_hashing_columns, priors=[0.01, 0.8, 0.19], pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)",
        "description": "Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein20].\nExamples",
        "Parameters": {
            "adata AnnData": "The (annotated) data matrix of shape n_obs \u00d7 n_vars.\nRows correspond to cells and columns to genes.",
            "cell_hashing_columns list": "A list specifying .obs columns that contain cell hashing counts.",
            "priors list (default: [0.01, 0.8, 0.19])": "A list specifying the prior probability of each hypothesis, in\nthe order [negative, singlet, doublet]. The default is set to\n[0.01, 0.8, 0.19] assuming barcode counts are from cells that\nhave passed QC in the transcriptome space, e.g. UMI counts, pct\nmito reads, etc.",
            "pre_existing_clusters str (default: None)": "The column in .obs containing pre-existing cluster assignments\n(e.g. Leiden clusters or cell types, but not batch assignments).\nIf provided, demultiplexing will be performed separately for each\ncluster.",
            "number_of_noise_barcodes int (default: None)": "The number of barcodes used to create the noise distribution.\nDefaults to len(cell_hashing_columns) - 2.",
            "inplace bool (default: True)": "Whether to update adata in-place or return a copy."
        },
        "Returns": "adata : AnnData\nA copy of the input adata if inplace=False, otherwise the input\nadata. The following fields are added:\n\n.obs[\"most_likely_hypothesis\"]Index of the most likely hypothesis, where 0 corresponds to negative,\n1 to singlet, and 2 to doublet.\n\n.obs[\"cluster_feature\"]The cluster assignments used for demultiplexing.\n\n.obs[\"negative_hypothesis_probability\"]Probability of the negative hypothesis.\n\n.obs[\"singlet_hypothesis_probability\"]Probability of the singlet hypothesis.\n\n.obs[\"doublet_hypothesis_probability\"]Probability of the doublet hypothesis.\n\n.obs[\"Classification\"]:Classification of the cell, one of the barcodes in cell_hashing_columns,\n\"Negative\", or \"Doublet\".\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.dca.html": {
        "function_name": "scanpy.external.pp.dca(adata, mode='denoise', ae_type='nb-conddisp', normalize_per_cell=True, scale=True, log1p=True, hidden_size=(64, 32, 64), hidden_dropout=0.0, batchnorm=True, activation='relu', init='glorot_uniform', network_kwds=mappingproxy({}), epochs=300, reduce_lr=10, early_stop=15, batch_size=32, optimizer='RMSprop', random_state=0, threads=None, learning_rate=None, verbose=False, training_kwds=mappingproxy({}), return_model=False, return_info=False, copy=False)",
        "description": "Deep count autoencoder [Eraslan18].\nFits a count autoencoder to the raw count data given in the anndata object\nin order to denoise the data and to capture hidden representation of\ncells in low dimensions. Type of the autoencoder and return values are\ndetermined by the parameters.",
        "Parameters": {
            "adata AnnData": "An anndata file with .raw attribute representing raw counts.",
            "mode {\u2018denoise\u2019, \u2018latent\u2019}Literal[\u2018denoise\u2019, \u2018latent\u2019] (default: 'denoise')": "denoise overwrites adata.X with denoised expression values.\nIn latent mode DCA adds adata.obsm['X_dca'] to given adata\nobject. This matrix represent latent representation of cells via DCA.",
            "ae_type {\u2018zinb-conddisp\u2019, \u2018zinb\u2019, \u2018nb-conddisp\u2019, \u2018nb\u2019}Literal[\u2018zinb-conddisp\u2019, \u2018zinb\u2019, \u2018nb-conddisp\u2019, \u2018nb\u2019] (default: 'nb-conddisp')": "Type of the autoencoder. Return values and the architecture is\ndetermined by the type e.g. nb does not provide dropout\nprobabilities. Types that end with \u201c-conddisp\u201d, assumes that dispersion is mean dependant.",
            "normalize_per_cell bool (default: True)": "If true, library size normalization is performed using\nthe sc.pp.normalize_per_cell function in Scanpy and saved into adata\nobject. Mean layer is re-introduces library size differences by\nscaling the mean value of each cell in the output layer. See the\nmanuscript for more details.",
            "scale bool (default: True)": "If true, the input of the autoencoder is centered using\nsc.pp.scale function of Scanpy. Note that the output is kept as raw\ncounts as loss functions are designed for the count data.",
            "log1p bool (default: True)": "If true, the input of the autoencoder is log transformed with a\npseudocount of one using sc.pp.log1p function of Scanpy.",
            "hidden_size Sequence[int] (default: (64, 32, 64))": "Width of hidden layers.",
            "hidden_dropout float | Sequence[float]Union[float, Sequence[float]] (default: 0.0)": "Probability of weight dropout in the autoencoder (per layer if list\nor tuple).",
            "batchnorm bool (default: True)": "If true, batch normalization is performed.",
            "activation str (default: 'relu')": "Activation function of hidden layers.",
            "init str (default: 'glorot_uniform')": "Initialization method used to initialize weights.",
            "network_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Additional keyword arguments for the autoencoder.",
            "epochs int (default: 300)": "Number of total epochs in training.",
            "reduce_lr int (default: 10)": "Reduces learning rate if validation loss does not improve in given number of epochs.",
            "early_stop int (default: 15)": "Stops training if validation loss does not improve in given number of epochs.",
            "batch_size int (default: 32)": "Number of samples in the batch used for SGD.",
            "optimizer str (default: 'RMSprop')": "Type of optimization method used for training.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: 0)": "Seed for python, numpy and tensorflow.",
            "threads int | NoneOptional[int] (default: None)": "Number of threads to use in training. All cores are used by default.",
            "learning_rate float | NoneOptional[float] (default: None)": "Learning rate to use in the training.",
            "verbose bool (default: False)": "If true, prints additional information about training and architecture.",
            "training_kwds MappingMapping[str, Any] (default: mappingproxy({}))": "Additional keyword arguments for the training process.",
            "return_model bool (default: False)": "If true, trained autoencoder object is returned. See \u201cReturns\u201d.",
            "return_info bool (default: False)": "If true, all additional parameters of DCA are stored in adata.obsm such as dropout\nprobabilities (obsm[\u2018X_dca_dropout\u2019]) and estimated dispersion values\n(obsm[\u2018X_dca_dispersion\u2019]), in case that autoencoder is of type\nzinb or zinb-conddisp.",
            "copy bool (default: False)": "If true, a copy of anndata is returned."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "If copy is true and return_model is false, AnnData object is returned.\nIn \u201cdenoise\u201d mode, adata.X is overwritten with the denoised values.\nIn \u201clatent\u201d mode, latent low dimensional representation of cells are stored\nin adata.obsm['X_dca'] and adata.X is not modified.\nNote that these values are not corrected for library size effects.\nIf return_info is true, all estimated distribution parameters are stored\nin AnnData like this:\n\n.obsm[\"X_dca_dropout\"]The mixture coefficient (pi) of the zero component in ZINB,\ni.e. dropout probability (if ae_type is zinb or zinb-conddisp).\n\n.obsm[\"X_dca_dispersion\"]The dispersion parameter of NB.\n\n.uns[\"dca_loss_history\"]The loss history of the training.\nSee .history attribute of Keras History class for mode details.\n\n\nFinally, the raw counts are stored in .raw attribute of AnnData object.\nIf return_model is given, trained model is returned.\nWhen both copy and return_model are true,\na tuple of anndata and model is returned in that order.\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.magic.html": {
        "function_name": "scanpy.external.pp.magic(adata, name_list=None, *, knn=5, decay=1, knn_max=None, t=3, n_pca=100, solver='exact', knn_dist='euclidean', random_state=None, n_jobs=None, verbose=False, copy=None, **kwargs)",
        "description": "Markov Affinity-based Graph Imputation of Cells (MAGIC) API [vanDijk18].\nMAGIC is an algorithm for denoising and transcript recover of single cells\napplied to single-cell sequencing data. MAGIC builds a graph from the data\nand uses diffusion to smooth out noise and recover the data manifold.\nThe algorithm implemented here has changed primarily in two ways\ncompared to the algorithm described in [vanDijk18]. Firstly, we use\nthe adaptive kernel described in Moon et al, 2019 [Moon17] for\nimproved stability. Secondly, data diffusion is applied\nin the PCA space, rather than the data space, for speed and\nmemory improvements.\nMore information and bug reports\nhere. For help, visit\n<https://krishnaswamylab.org/get-help>.\nExamples",
        "Parameters": {
            "adata AnnData": "An anndata file with .raw attribute representing raw counts.",
            "name_list {\u2018all_genes\u2019, \u2018pca_only\u2019} | Sequence[str] | NoneUnion[Literal[\u2018all_genes\u2019, \u2018pca_only\u2019], Sequence[str], None] (default: None)": "Denoised genes to return. The default 'all_genes'/None\nmay require a large amount of memory if the input data is sparse.\nAnother possibility is 'pca_only'.",
            "knn int (default: 5)": "number of nearest neighbors on which to build kernel.",
            "decay float | NoneOptional[float] (default: 1)": "sets decay rate of kernel tails.\nIf None, alpha decaying kernel is not used.",
            "knn_max int | NoneOptional[int] (default: None)": "maximum number of nearest neighbors with nonzero connection.\nIf None, will be set to 3 * knn.",
            "t {\u2018auto\u2019} | intUnion[Literal[\u2018auto\u2019], int] (default: 3)": "power to which the diffusion operator is powered.\nThis sets the level of diffusion. If \u2018auto\u2019, t is selected\naccording to the Procrustes disparity of the diffused data.",
            "n_pca int | NoneOptional[int] (default: 100)": "Number of principal components to use for calculating\nneighborhoods. For extremely large datasets, using\nn_pca < 20 allows neighborhoods to be calculated in\nroughly log(n_samples) time. If None, no PCA is performed.",
            "solver {\u2018exact\u2019, \u2018approximate\u2019}Literal[\u2018exact\u2019, \u2018approximate\u2019] (default: 'exact')": "Which solver to use. \u201cexact\u201d uses the implementation described\nin van Dijk et al. (2018) [vanDijk18]. \u201capproximate\u201d uses a faster\nimplementation that performs imputation in the PCA space and then\nprojects back to the gene space. Note, the \u201capproximate\u201d solver may\nreturn negative values.",
            "knn_dist str (default: 'euclidean')": "recommended values: \u2018euclidean\u2019, \u2018cosine\u2019, \u2018precomputed\u2019\nAny metric from scipy.spatial.distance can be used\ndistance metric for building kNN graph. If \u2018precomputed\u2019,\ndata should be an n_samples x n_samples distance or\naffinity matrix.",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: None)": "Random seed. Defaults to the global numpy random number generator.",
            "n_jobs int | NoneOptional[int] (default: None)": "Number of threads to use in training. All cores are used by default.",
            "verbose bool (default: False)": "If True or an integer >= 2, print status messages.\nIf None, sc.settings.verbosity is used.",
            "copy bool | NoneOptional[bool] (default: None)": "If true, a copy of anndata is returned. If None, copy is True if\ngenes is not 'all_genes' or 'pca_only'. copy may only be False\nif genes is 'all_genes' or 'pca_only', as the resultant data\nwill otherwise have different column names from the input data.",
            "kwargs": "Additional arguments to magic.MAGIC."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "If copy is True, AnnData object is returned.\nIf subset_genes is not all_genes, PCA on MAGIC values of cells are\nstored in adata.obsm['X_magic'] and adata.X is not modified.\nThe raw counts are stored in .raw attribute of AnnData object.\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.phate.html": {
        "function_name": "scanpy.external.tl.phate(adata, n_components=2, k=5, a=15, n_landmark=2000, t='auto', gamma=1.0, n_pca=100, knn_dist='euclidean', mds_dist='euclidean', mds='metric', n_jobs=None, random_state=None, verbose=None, copy=False, **kwargs)",
        "description": "PHATE [Moon17].\nPotential of Heat-diffusion for Affinity-based Trajectory Embedding (PHATE)\nembeds high dimensional single-cell data into two or three dimensions for\nvisualization of biological progressions.\nFor more information and access to the object-oriented interface, read the\nPHATE documentation.  For\ntutorials, bug reports, and R/MATLAB implementations, visit the PHATE\nGitHub page. For help\nusing PHATE, go here.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_components int (default: 2)": "number of dimensions in which the data will be embedded",
            "k int (default: 5)": "number of nearest neighbors on which to build kernel",
            "a int (default: 15)": "sets decay rate of kernel tails.\nIf None, alpha decaying kernel is not used",
            "n_landmark int (default: 2000)": "number of landmarks to use in fast PHATE",
            "t int | strUnion[int, str] (default: 'auto')": "power to which the diffusion operator is powered\nsets the level of diffusion. If \u2018auto\u2019, t is selected\naccording to the knee point in the Von Neumann Entropy of\nthe diffusion operator",
            "gamma float (default: 1.0)": "Informational distance constant between -1 and 1.\ngamma=1 gives the PHATE log potential, gamma=0 gives\na square root potential.",
            "n_pca int (default: 100)": "Number of principal components to use for calculating\nneighborhoods. For extremely large datasets, using\nn_pca < 20 allows neighborhoods to be calculated in\nlog(n_samples) time.",
            "knn_dist str (default: 'euclidean')": "recommended values: \u2018euclidean\u2019 and \u2018cosine\u2019\nAny metric from scipy.spatial.distance can be used\ndistance metric for building kNN graph",
            "mds_dist str (default: 'euclidean')": "recommended values: \u2018euclidean\u2019 and \u2018cosine\u2019\nAny metric from scipy.spatial.distance can be used\ndistance metric for MDS",
            "mds {\u2018classic\u2019, \u2018metric\u2019, \u2018nonmetric\u2019}Literal[\u2018classic\u2019, \u2018metric\u2019, \u2018nonmetric\u2019] (default: 'metric')": "Selects which MDS algorithm is used for dimensionality reduction.",
            "n_jobs int | NoneOptional[int] (default: None)": "The number of jobs to use for the computation.\nIf None, sc.settings.n_jobs is used.\nIf -1 all CPUs are used. If 1 is given, no parallel computing code is\nused at all, which is useful for debugging.\nFor n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for\nn_jobs = -2, all CPUs but one are used",
            "random_state None | int | RandomStateUnion[None, int, RandomState] (default: None)": "Random seed. Defaults to the global numpy random number generator",
            "verbose bool | int | NoneUnion[bool, int, None] (default: None)": "If True or an int/Verbosity \u2265 2/hint, print status messages.\nIf None, sc.settings.verbosity is used.",
            "copy bool (default: False)": "Return a copy instead of writing to adata.",
            "kwargs": "Additional arguments to phate.PHATE"
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nX_phatenp.ndarray, (adata.obs, shape=[n_samples, n_components], dtype float)PHATE coordinates of data.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.palantir.html": {
        "function_name": "scanpy.external.tl.palantir(adata, n_components=10, knn=30, alpha=0, use_adjacency_matrix=False, distances_key=None, n_eigs=None, impute_data=True, n_steps=3, copy=False)",
        "description": "Run Diffusion maps using the adaptive anisotropic kernel [Setty18].\nPalantir is an algorithm to align cells along differentiation trajectories.\nPalantir models differentiation as a stochastic process where stem cells\ndifferentiate to terminally differentiated cells by a series of steps through\na low dimensional phenotypic manifold. Palantir effectively captures the\ncontinuity in cell states and the stochasticity in cell fate determination.\nPalantir has been designed to work with multidimensional single cell data\nfrom diverse technologies such as Mass cytometry and single cell RNA-seq.\nExample\nA sample data is available here.\nLoad sample data\nCleanup and normalize\nData preprocessing\nPalantir builds diffusion maps using one of two optional inputs:\nPrincipal component analysis\nor,\nNearist neighbors graph\nDiffusion maps\nPalantir determines the diffusion maps of the data as an estimate of the low\ndimensional phenotypic manifold of the data.\nif pre-computed distances are to be used,\nVisualizing Palantir results\ntSNE visualization\nimportant for Palantir!\nPalantir constructs the tSNE map in the embedded space since these maps better\nrepresent the differentiation trajectories.\ntsne by cell size\nImputed gene expression visualized on tSNE maps\nRunning Palantir\nPalantir can be run by specifying an approximate early cell. While Palantir\nautomatically determines the terminal states, they can also be specified using the\ntermine_states parameter.\nAt this point the returned Palantir object pr_res can be used for all downstream\nanalysis and plotting. Please consult this notebook\nPalantir_sample_notebook.ipynb.\nIt provides a comprehensive guide to draw gene expression trends, amongst other\nthings.",
        "Parameters": {
            "adata AnnData": "An AnnData object.",
            "n_components int (default: 10)": "Number of diffusion components.",
            "knn int (default: 30)": "Number of nearest neighbors for graph construction.",
            "alpha float (default: 0)": "Normalization parameter for the diffusion operator.",
            "use_adjacency_matrix bool (default: False)": "Use adaptive anisotropic adjacency matrix, instead of PCA projections\n(default) to compute diffusion components.",
            "distances_key str | NoneOptional[str] (default: None)": "With use_adjacency_matrix=True, use the indicated distances key for .obsp.\nIf None, 'distances'.",
            "n_eigs int (default: None)": "Number of eigen vectors to use. If None specified, the number of eigen\nvectors will be determined using eigen gap. Passed to\npalantir.utils.determine_multiscale_space.",
            "impute_data bool (default: True)": "Impute data using MAGIC.",
            "n_steps int (default: 3)": "Number of steps in the diffusion operator. Passed to\npalantir.utils.run_magic_imputation.",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields:\n\nDiffusion maps,used for magic imputation, and to generate multi-scale data matrix,\n\n\nX_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components.\n\n\n\n\npalantir_EigenValues - ndarray (uns, dtype float)Array of corresponding eigen values.\n\n\n\n\npalantir_diff_op - spmatrix (obsp, dtype float)The diffusion operator matrix.\n\n\n\n\n\nMulti scale space results,used to build tsne on diffusion components, and to compute branch probabilities\nand waypoints,\n\n\nX_palantir_multiscale - ndarray (obsm, dtype float)Multi scale data matrix.\n\n\n\n\n\nMAGIC imputation,used for plotting gene expression on tsne, and gene expression trends,\n\n\npalantir_imp - ndarray (layers, dtype float)Imputed data matrix (MAGIC imputation).\n\n\n\n\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.trimap.html": {
        "function_name": "scanpy.external.tl.trimap(adata, n_components=2, n_inliers=10, n_outliers=5, n_random=5, metric='euclidean', weight_adj=500.0, lr=1000.0, n_iters=400, verbose=None, copy=False)",
        "description": "TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid19].\nTriMap is a dimensionality reduction method that uses triplet constraints\nto form a low-dimensional embedding of a set of points. The triplet\nconstraints are of the form \u201cpoint i is closer to point j than point k\u201d.\nThe triplets are sampled from the high-dimensional representation of the\npoints and a weighting scheme is used to reflect the importance of each\ntriplet.\nTriMap provides a significantly better global view of the data than the\nother dimensionality reduction methods such t-SNE, LargeVis, and UMAP.\nThe global structure includes relative distances of the clusters, multiple\nscales in the data, and the existence of possible outliers. We define a\nglobal score to quantify the quality of an embedding in reflecting the\nglobal structure of the data.\nExample",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "n_components int (default: 2)": "Number of dimensions of the embedding.",
            "n_inliers int (default: 10)": "Number of inlier points for triplet constraints.",
            "n_outliers int (default: 5)": "Number of outlier points for triplet constraints.",
            "n_random int (default: 5)": "Number of random triplet constraints per point.",
            "metric {\u2018angular\u2019, \u2018euclidean\u2019, \u2018hamming\u2019, \u2018manhattan\u2019}Literal[\u2018angular\u2019, \u2018euclidean\u2019, \u2018hamming\u2019, \u2018manhattan\u2019] (default: 'euclidean')": "Distance measure: \u2018angular\u2019, \u2018euclidean\u2019, \u2018hamming\u2019, \u2018manhattan\u2019.",
            "weight_adj float (default: 500.0)": "Adjusting the weights using a non-linear transformation.",
            "lr float (default: 1000.0)": "Learning rate.",
            "n_iters int (default: 400)": "Number of iterations.",
            "verbose bool | int | NoneUnion[bool, int, None] (default: None)": "If True, print the progress report.\nIf None, sc.settings.verbosity is used.",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates adata with the following fields.\n\nX_trimapndarray, (obsm, shape=(n_samples, n_components), dtype float)TriMap coordinates of data.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.sam.html": {
        "function_name": "scanpy.external.tl.sam(adata, max_iter=10, num_norm_avg=50, k=20, distance='correlation', standardization='StandardScaler', weight_pcs=False, sparse_pca=False, n_pcs=150, n_genes=3000, projection='umap', inplace=True, verbose=True)",
        "description": "Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky19].\nSAM iteratively rescales the input gene expression matrix to emphasize\ngenes that are spatially variable along the intrinsic manifold of the data.\nIt outputs the gene weights, nearest neighbor matrix, and a 2D projection.\nThe AnnData input should contain unstandardized, non-negative values.\nPreferably, the data should be log-normalized and no genes should be filtered out.\nExample\n* Running SAM *\nAssuming we are given an AnnData object called adata, we can run the SAM\nalgorithm as follows:\nThe input AnnData object should contain unstandardized, non-negative\nexpression values. Preferably, the data should be log-normalized and no\ngenes should be filtered out.\nPlease see the documentation for a description of all available parameters.\nFor more detailed tutorials, please visit the original Github repository:\natarashansky/self-assembling-manifold\n* Plotting *\nTo visualize the output, we can use:\nsce.pl.sam accepts all keyword arguments used in the\nmatplotlib.pyplot.scatter function.\n* SAMGUI *\nSAM comes with the SAMGUI module, a graphical-user interface written with\nPlotly and ipythonwidgets for interactively exploring and annotating\nthe scRNAseq data and running SAM.\nDependencies can be installed with Anaconda by following the instructions in\nthe self-assembling-manifold Github README:\natarashansky/self-assembling-manifold\nIn a Jupyter notebook, execute the following to launch the interface:\nThis can also be enabled in Jupyer Lab by following the instructions in the\nself-assembling-manifold README.",
        "Parameters": {
            "k int (default: 20)": "The number of nearest neighbors to identify for each cell.",
            "distance str (default: 'correlation')": "The distance metric to use when identifying nearest neighbors.\nCan be any of the distance metrics supported by\npdist().",
            "max_iter int (default: 10)": "The maximum number of iterations SAM will run.",
            "projection {\u2018umap\u2019, \u2018tsne\u2019, \u2018None\u2019}Literal[\u2018umap\u2019, \u2018tsne\u2019, \u2018None\u2019] (default: 'umap')": "If \u2018tsne\u2019, generates a t-SNE embedding. If \u2018umap\u2019, generates a UMAP\nembedding. If \u2018None\u2019, no embedding will be generated.",
            "standardization {\u2018Normalizer\u2019, \u2018StandardScaler\u2019, \u2018None\u2019}Literal[\u2018Normalizer\u2019, \u2018StandardScaler\u2019, \u2018None\u2019] (default: 'StandardScaler')": "If \u2018Normalizer\u2019, use sklearn.preprocessing.Normalizer, which\nnormalizes expression data prior to PCA such that each cell has\nunit L2 norm. If \u2018StandardScaler\u2019, use\nsklearn.preprocessing.StandardScaler, which normalizes expression\ndata prior to PCA such that each gene has zero mean and unit\nvariance. Otherwise, do not normalize the expression data. We\nrecommend using \u2018StandardScaler\u2019 for large datasets with many\nexpected cell types and \u2018Normalizer\u2019 otherwise. If \u2018None\u2019, no\ntransformation is applied.",
            "num_norm_avg int (default: 50)": "The top \u2018num_norm_avg\u2019 dispersions are averaged to determine the\nnormalization factor when calculating the weights. This prevents\ngenes with large spatial dispersions from skewing the distribution\nof weights.",
            "weight_pcs bool (default: False)": "If True, scale the principal components by their eigenvalues. In\ndatasets with many expected cell types, setting this to False might\nimprove the resolution as these cell types might be encoded by lower-\nvariance principal components.",
            "sparse_pca bool (default: False)": "If True, uses an implementation of PCA that accepts sparse inputs.\nThis way, we no longer need a temporary dense copy of the sparse data.\nHowever, this implementation is slower and so is only worth using when\nmemory constraints become noticeable.",
            "n_pcs int | NoneOptional[int] (default: 150)": "Determines the number of top principal components selected at each\niteration of the SAM algorithm. If None, this number is chosen\nautomatically based on the size of the dataset. If weight_pcs is\nset to True, this parameter primarily affects the runtime of the SAM\nalgorithm (more PCs = longer runtime).",
            "n_genes int | NoneOptional[int] (default: 3000)": "Determines the number of top SAM-weighted genes to use at each iteration\nof the SAM algorithm. If None, this number is chosen automatically\nbased on the size of the dataset. This parameter primarily affects\nthe runtime of the SAM algorithm (more genes = longer runtime). For\nextremely homogeneous datasets, decreasing n_genes may improve\nclustering resolution.",
            "inplace bool (default: True)": "Set fields in adata if True. Otherwise, returns a copy.",
            "verbose bool (default: True)": "If True, displays SAM log statements."
        },
        "Return type": "Any | Tuple[Any, AnnData]Union[Any, Tuple[Any, AnnData]]",
        "Returns": "sam_obj if inplace is True or (sam_obj,AnnData) otherwise\n\nadata - AnnData\n.var['weights']SAM weights for each gene.\n\n.var['spatial_dispersions']Spatial dispersions for each gene (these are used to compute the\nSAM weights)\n\n.uns['sam']Dictionary of SAM-specific outputs, such as the parameters\nused for preprocessing (\u2018preprocess_args\u2019) and running\n(\u2018run_args\u2019) SAM.\n\n.uns['neighbors']A dictionary with key \u2018connectivities\u2019 containing the kNN adjacency\nmatrix output by SAM. If built-in scanpy dimensionality reduction\nmethods are to be used using the SAM-output AnnData, users\nshould recompute the neighbors using .obs['X_pca'] with\nscanpy.pp.neighbors.\n\n.obsm['X_pca']The principal components output by SAM.\n\n.obsm['X_umap']The UMAP projection output by SAM.\n\n.layers['X_disp']The expression matrix used for nearest-neighbor averaging.\n\n.layers['X_knn_avg']The nearest-neighbor-averaged expression data used for computing the\nspatial dispersions of genes.\n\n\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.phenograph.html": {
        "function_name": "scanpy.external.tl.phenograph(adata, clustering_algo='louvain', k=30, directed=False, prune=False, min_cluster_size=10, jaccard=True, primary_metric='euclidean', n_jobs=- 1, q_tol=0.001, louvain_time_limit=2000, nn_method='kdtree', partition_type=None, resolution_parameter=1, n_iterations=- 1, use_weights=True, seed=None, copy=False, **kargs)",
        "description": "PhenoGraph clustering [Levine15].\nPhenoGraph is a clustering method designed for high-dimensional single-cell\ndata. It works by creating a graph (\u201cnetwork\u201d) representing phenotypic similarities\nbetween cells and then identifying communities in this graph. It supports both\nLouvain and Leiden algorithms for community detection.\nExample\nWith annotated data as input:\nThen do PCA:\nCompute phenograph clusters:\nLouvain community detection\nLeiden community detection\nReturn only Graph object\nNow to show phenograph on tSNE (for example):\nCompute tSNE:\nPlot phenograph clusters on tSNE:\nCluster and cluster centroids for input Numpy ndarray",
        "Parameters": {
            "adata AnnData | ndarray | spmatrixUnion[AnnData, ndarray, spmatrix]": "AnnData, or Array of data to cluster, or sparse matrix of k-nearest neighbor\ngraph. If ndarray, n-by-d array of n cells in d dimensions. if sparse matrix,\nn-by-n adjacency matrix.",
            "clustering_algo {\u2018louvain\u2019, \u2018leiden\u2019} | NoneOptional[Literal[\u2018louvain\u2019, \u2018leiden\u2019]] (default: 'louvain')": "Choose between 'Louvain' or 'Leiden' algorithm for clustering.",
            "k int (default: 30)": "Number of nearest neighbors to use in first step of graph construction.",
            "directed bool (default: False)": "Whether to use a symmetric (default) or asymmetric ('directed') graph.\nThe graph construction process produces a directed graph, which is symmetrized\nby one of two methods (see prune below).",
            "prune bool (default: False)": "prune=False, symmetrize by taking the average between the graph and its\ntranspose. prune=True, symmetrize by taking the product between the graph\nand its transpose.",
            "min_cluster_size int (default: 10)": "Cells that end up in a cluster smaller than min_cluster_size are considered\noutliers and are assigned to -1 in the cluster labels.",
            "jaccard bool (default: True)": "If True, use Jaccard metric between k-neighborhoods to build graph. If\nFalse, use a Gaussian kernel.",
            "primary_metric {\u2018euclidean\u2019, \u2018manhattan\u2019, \u2018correlation\u2019, \u2018cosine\u2019}Literal[\u2018euclidean\u2019, \u2018manhattan\u2019, \u2018correlation\u2019, \u2018cosine\u2019] (default: 'euclidean')": "Distance metric to define nearest neighbors. Note that performance will be\nslower for correlation and cosine.",
            "n_jobs int (default: -1)": "Nearest Neighbors and Jaccard coefficients will be computed in parallel using\nn_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.\nFor n_jobs below -1, n_cpus + 1 + n_jobs are used.",
            "q_tol float (default: 0.001)": "Tolerance, i.e. precision, for monitoring modularity optimization.",
            "louvain_time_limit int (default: 2000)": "Maximum number of seconds to run modularity optimization. If exceeded the best\nresult so far is returned.",
            "nn_method {\u2018kdtree\u2019, \u2018brute\u2019}Literal[\u2018kdtree\u2019, \u2018brute\u2019] (default: 'kdtree')": "Whether to use brute force or kdtree for nearest neighbor search.\nFor very large high-dimensional data sets, brute force, with parallel\ncomputation, performs faster than kdtree.",
            "partition_type Type[MutableVertexPartition] | NoneOptional[Type[MutableVertexPartition]] (default: None)": "Defaults to RBConfigurationVertexPartition. For the\navailable options, consult the documentation for\nfind_partition().",
            "resolution_parameter float (default: 1)": "A parameter value controlling the coarseness of the clustering in Leiden. Higher\nvalues lead to more clusters. Set to None if overriding partition_type to\none that does not accept a resolution_parameter.",
            "n_iterations int (default: -1)": "Number of iterations to run the Leiden algorithm. If the number of iterations is\nnegative, the Leiden algorithm is run until an iteration in which there was no\nimprovement.",
            "use_weights bool (default: True)": "Use vertices in the Leiden computation.",
            "seed int | NoneOptional[int] (default: None)": "Leiden initialization of the optimization.",
            "copy bool (default: False)": "Return a copy or write to adata.",
            "kargs Any": "Additional arguments passed to find_partition() and the\nconstructor of the partition_type."
        },
        "Return type": "Tuple[Optional[ndarray], spmatrix, Optional[float]]",
        "Returns": "Depending on copy, returns or updates adata with the following fields:\n\ncommunities - ndarray (obs, dtype int)integer array of community assignments for each row in data.\n\ngraph - spmatrix (obsp, dtype float)the graph that was used for clustering.\n\nQ - float (uns, dtype float)the modularity score for communities on graph.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.harmony_timeseries.html": {
        "function_name": "scanpy.external.tl.harmony_timeseries(adata, tp, n_neighbors=30, n_components=1000, n_jobs=- 2, copy=False)",
        "description": "Harmony time series for data visualization with augmented affinity matrix\nat discrete time points [Nowotschin18i].\nHarmony time series is a framework for data visualization, trajectory\ndetection and interpretation for scRNA-seq data measured at discrete\ntime points. Harmony constructs an augmented affinity matrix by augmenting\nthe kNN graph affinity matrix with mutually nearest neighbors between\nsuccessive time points. This augmented affinity matrix forms the basis for\ngenerated a force directed layout for visualization and also serves as input\nfor computing the diffusion operator which can be used for trajectory\ndetection using Palantir.\nExample\nLoad AnnData\nA sample with real data is available here.\nRandom data sets of three time points with two replicates each:\nNormalize and filter for highly expressed genes\nRun harmony_timeseries\nPlot time points:\nFor further demonstration of Harmony visualizations please follow the notebook\nHarmony_sample_notebook.ipynb.\nIt provides a comprehensive guide to draw gene expression trends,\namongst other things.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix of shape n_obs \u00d7 n_vars. Rows correspond to\ncells and columns to genes. Rows represent two or more time points,\nwhere replicates of the same time point are consecutive in order.",
            "tp str": "key name of observation annotation .obs representing time points. Time\npoints should be categorical of dtype=category. The unique categories for\nthe categorical will be used as the time points to construct the timepoint\nconnections.",
            "n_neighbors int (default: 30)": "Number of nearest neighbors for graph construction.",
            "n_components int | NoneOptional[int] (default: 1000)": "Minimum number of principal components to use. Specify None to use\npre-computed components. The higher the value the better to capture 85% of the\nvariance.",
            "n_jobs int (default: -2)": "Nearest Neighbors will be computed in parallel using n_jobs.",
            "copy bool (default: False)": "Return a copy instead of writing to adata."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "Depending on copy, returns or updates .obsm, .obsp and .uns with the following:\n\nX_harmony - ndarray (obsm, dtype float)force directed layout\n\nharmony_aff - spmatrix (obsp, dtype float)affinity matrix\n\nharmony_aff_aug - spmatrix (obsp, dtype float)augmented affinity matrix\n\nharmony_timepoint_var - str (uns)The name of the variable passed as tp\n\nharmony_timepoint_connections - ndarray (uns, dtype str)The links between time points\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.wishbone.html": {
        "function_name": "scanpy.external.tl.wishbone(adata, start_cell, branch=True, k=15, components=(1, 2, 3), num_waypoints=250)",
        "description": "Wishbone identifies bifurcating developmental trajectories from single-cell data\n[Setty16].\nWishbone is an algorithm for positioning single cells along bifurcating\ndevelopmental trajectories with high resolution. Wishbone uses multi-dimensional\nsingle-cell data, such as mass cytometry or RNA-Seq data, as input and orders cells\naccording to their developmental progression, and it pinpoints bifurcation points\nby labeling each cell as pre-bifurcation or as one of two post-bifurcation cell\nfates.\nExample\nLoading Data and Pre-processing\nRunning Wishbone Core Function\nUsually, the start cell for a dataset should be chosen based on high expression of\nthe gene of interest:\nVisualizing Wishbone results\nFor further demonstration of Wishbone methods and visualization please follow the\nnotebooks in the package Wishbone_for_single_cell_RNAseq.ipynb.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "start_cell str": "Desired start cell from obs_names.",
            "branch bool (default: True)": "Use True for Wishbone and False for Wanderlust.",
            "k int (default: 15)": "Number of nearest neighbors for graph construction.",
            "components Iterable[int] (default: (1, 2, 3))": "Components to use for running Wishbone.",
            "num_waypoints int | CollectionUnion[int, Collection] (default: 250)": "Number of waypoints to sample."
        },
        "Returns": "Updates adata with the following fields:\n\ntrajectory_wishbone(adata.obs, dtype float64)Computed trajectory positions.\n\nbranch_wishbone(adata.obs, dtype int64)Assigned branches.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.palantir_results.html": {
        "function_name": "scanpy.external.tl.palantir_results(adata, early_cell, ms_data='X_palantir_multiscale', terminal_states=None, knn=30, num_waypoints=1200, n_jobs=- 1, scale_components=True, use_early_cell_as_start=False, max_iterations=25)",
        "description": "Running Palantir\nA convenience function that wraps palantir.core.run_palantir to compute branch\nprobabilities and waypoints.",
        "Parameters": {
            "adata AnnData": "An AnnData object.",
            "early_cell str": "Start cell for pseudotime construction.",
            "ms_data str (default: 'X_palantir_multiscale')": "Palantir multi scale data matrix,",
            "terminal_states List (default: None)": "List of user defined terminal states",
            "knn int (default: 30)": "Number of nearest neighbors for graph construction.",
            "num_waypoints int (default: 1200)": "Number of waypoints to sample.",
            "n_jobs int (default: -1)": "Number of jobs for parallel processing.",
            "scale_components bool (default: True)": "Transform features by scaling each feature to a given range. Consult the\ndocumentation for sklearn.preprocessing.minmax_scale.",
            "use_early_cell_as_start bool (default: False)": "Use early_cell as start_cell, instead of determining it from the boundary\ncells closest to the defined early_cell.",
            "max_iterations int (default: 25)": "Maximum number of iterations for pseudotime convergence."
        },
        "Return type": "AnnData | NoneOptional[AnnData]",
        "Returns": "PResults\nPResults object with pseudotime, entropy, branch probabilities and waypoints.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.sandbag.html": {
        "function_name": "scanpy.external.tl.sandbag(adata, annotation=None, *, fraction=0.65, filter_genes=None, filter_samples=None)",
        "description": "Calculate marker pairs of genes. [Scialdone15] [Fechtner18].\nCalculates the pairs of genes serving as marker pairs for each phase,\nbased on a matrix of gene counts and an annotation of known phases.\nThis reproduces the approach of [Scialdone15] in the implementation of\n[Fechtner18].\nMore information and bug reports here.\nExamples",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "annotation Mapping | NoneOptional[Mapping[str, Collection[Union[str, int, bool]]]] (default: None)": "Mapping from category to genes, e.g. {'phase': [Gene1, ...]}.\nDefaults to data.vars['category'].",
            "fraction float (default: 0.65)": "Fraction of cells per category where marker criteria must be satisfied.",
            "filter_genes Collection[Union[str, int, bool]] | NoneOptional[Collection[Union[str, int, bool]]] (default: None)": "Genes for sampling the reference set. Defaults to all genes.",
            "filter_samples Collection[Union[str, int, bool]] | NoneOptional[Collection[Union[str, int, bool]]] (default: None)": "Cells for sampling the reference set. Defaults to all samples."
        },
        "Return type": "{str: List[Tuple[str, str]]}Dict[str, List[Tuple[str, str]]]",
        "Returns": "A dict mapping from category to lists of marker pairs, e.g.:\n{'Category_1': [(Gene_1, Gene_2), ...], ...}.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/external/generated/scanpy.external.tl.cyclone.html": {
        "function_name": "scanpy.external.tl.cyclone(adata, marker_pairs=None, *, iterations=1000, min_iter=100, min_pairs=50)",
        "description": "Assigns scores and predicted class to observations [Scialdone15] [Fechtner18].\nCalculates scores for each observation and each phase and assigns prediction\nbased on marker pairs indentified by sandbag().\nThis reproduces the approach of [Scialdone15] in the implementation of\n[Fechtner18].",
        "Parameters": {
            "adata AnnData": "The annotated data matrix.",
            "marker_pairs Mapping | NoneOptional[Mapping[str, Collection[Tuple[str, str]]]] (default: None)": "Mapping of categories to lists of marker pairs.\nSee sandbag() output.",
            "iterations int (default: 1000)": "An integer scalar specifying the number of\niterations for random sampling to obtain a cycle score.",
            "min_iter int (default: 100)": "An integer scalar specifying the minimum number of iterations\nfor score estimation.",
            "min_pairs int (default: 50)": "An integer scalar specifying the minimum number of pairs\nfor score estimation."
        },
        "Return type": "DataFrame",
        "Returns": "A DataFrame with samples as index and categories as columns\nwith scores for each category for each sample and a additional column with\nthe name of the max scoring category for each sample.\nIf marker_pairs contains only the cell cycle categories G1, S and G2M an\nadditional column pypairs_cc_prediction will be added.\nWhere category S is assigned to samples where G1 and G2M score are < 0.5.\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pl.phate.html": {
        "function_name": "scanpy.external.pl.phate(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot in PHATE basis.\nExamples",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "List[Axes] | NoneOptional[List[Axes]]",
        "Returns": "If show==False, a list of Axes objects.\nEvery second element corresponds to the \u2018right margin\u2019\ndrawing area for color bars and legends.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pl.trimap.html": {
        "function_name": "scanpy.external.pl.trimap(adata, *, color=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)",
        "description": "Scatter plot in TriMap basis.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "color str | Sequence[str] | NoneUnion[str, Sequence[str], None] (default: None)": "Keys for annotations of observations/cells or variables/genes, e.g.,\n'ann1' or ['ann1', 'ann2'].",
            "gene_symbols str | NoneOptional[str] (default: None)": "Column name in .var DataFrame that stores gene symbols. By default var_names\nrefer to the index column of the .var DataFrame. Setting this option allows\nalternative names to be used.",
            "use_raw bool | NoneOptional[bool] (default: None)": "Use .raw attribute of adata for coloring with gene expression. If None,\ndefaults to True if layer isn\u2019t provided and adata.raw is present.",
            "layer str | NoneOptional[str] (default: None)": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.\nIf layer is set to a valid layer name, then the layer is plotted. layer\ntakes precedence over use_raw.",
            "edges bool (default: False)": "Show edges.",
            "edges_width float (default: 0.1)": "Width of edges.",
            "edges_color str | Sequence[float] | Sequence[str]Union[str, Sequence[float], Sequence[str]] (default: 'grey')": "Color of edges. See draw_networkx_edges().",
            "neighbors_key str | NoneOptional[str] (default: None)": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp[\u2018connectivities\u2019] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key][\u2018connectivities_key\u2019]] for connectivities.",
            "arrows bool (default: False)": "Show arrows (deprecated in favour of scvelo.pl.velocity_embedding).",
            "arrows_kwds Mapping | NoneOptional[Mapping[str, Any]] (default: None)": "Passed to quiver()",
            "sort_order bool (default: True)": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
            "groups str | NoneOptional[str] (default: None)": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
            "dimensions Tuple[int, int] | Sequence[Tuple[int, int]] | NoneUnion[Tuple[int, int], Sequence[Tuple[int, int]], None] (default: None)": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike components, this argument is used in the same way as colors, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
            "components str | Sequence[str]Union[str, Sequence[str]] (default: None)": "For instance, ['1,2', '2,3']. To plot all available components use\ncomponents='all'.",
            "projection {\u20182d\u2019, \u20183d\u2019}Literal[\u20182d\u2019, \u20183d\u2019] (default: '2d')": "Projection of plot (default: '2d').",
            "show bool | NoneOptional[bool] (default: None)": "Show the plot, do not return axis.",
            "save bool | str | NoneUnion[bool, str, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Return type": "Axes | List[Axes] | NoneUnion[Axes, List[Axes], None]",
        "Returns": "If show==False a Axes or a list of it.\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pl.sam.html": {
        "function_name": "scanpy.external.pl.sam(adata, projection='X_umap', c=None, cmap='Spectral_r', linewidth=0.0, edgecolor='k', axes=None, colorbar=True, s=10.0, **kwargs)",
        "description": "Scatter plot using the SAM projection or another input projection.",
        "Parameters": {
            "projection str | ndarrayUnion[str, ndarray] (default: 'X_umap')": "A case-sensitive string indicating the projection to display (a key\nin adata.obsm) or a 2D numpy array with cell coordinates. If None,\nprojection defaults to UMAP.",
            "c str | ndarray | NoneUnion[str, ndarray, None] (default: None)": "Cell color values overlaid on the projection. Can be a string from adata.obs\nto overlay cluster assignments / annotations or a 1D numpy array.",
            "axes Axes | NoneOptional[Axes] (default: None)": "Plot output to the specified, existing axes. If None, create new\nfigure window.",
            "kwargs Any": "all keyword arguments in matplotlib.pyplot.scatter are eligible."
        },
        "Return type": "Axes"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pl.wishbone_marker_trajectory.html": {
        "function_name": "scanpy.external.pl.wishbone_marker_trajectory(adata, markers, no_bins=150, smoothing_factor=1, min_delta=0.1, show_variance=False, figsize=None, return_fig=False, show=True, save=None, ax=None)",
        "description": "Plot marker trends along trajectory, and return trajectory branches for further\nanalysis and visualization (heatmap, etc..)",
        "Parameters": {
            "adata AnnData": "Annotated data matrix.",
            "markers Collection[str]": "Iterable of markers/genes to be plotted.",
            "show_variance bool (default: False)": "Logical indicating if the trends should be accompanied with variance.",
            "no_bins int (default: 150)": "Number of bins for calculating marker density.",
            "smoothing_factor int (default: 1)": "Parameter controlling the degree of smoothing.",
            "min_delta float (default: 0.1)": "Minimum difference in marker expression after normalization to show\nseparate trends for the two branches.",
            "figsize Tuple[float, float] | NoneOptional[Tuple[float, float]] (default: None)": "width, height",
            "return_fig bool (default: False)": "Return the matplotlib figure.",
            "show bool (default: True)": "Show the plot, do not return axis.",
            "save str | bool | NoneUnion[str, bool, None] (default: None)": "If True or a str, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {'.pdf', '.png', '.svg'}.",
            "ax Axes | NoneOptional[Axes] (default: None)": "A matplotlib axes object. Only works if plotting a single component."
        },
        "Returns": "Updates adata with the following fields:\n\ntrunk_wishbonepandas.DataFrame (adata.uns)Computed values before branching\n\nbranch1_wishbonepandas.DataFrame (adata.uns)Computed values for the first branch\n\nbranch2_wishbonepandas.DataFrame (adata.uns)Computed values for the second branch.\n\n\n\n"
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.exporting.spring_project.html": {
        "function_name": "scanpy.external.exporting.spring_project(adata, project_dir, embedding_method, subplot_name=None, cell_groupings=None, custom_color_tracks=None, total_counts_key='n_counts', neighbors_key=None, overwrite=False)",
        "description": "Exports to a SPRING project directory [Weinreb17].\nVisualize annotation present in adata. By default, export all gene expression data\nfrom adata.raw and categorical and continuous annotations present in adata.obs.\nSee SPRING or [Weinreb17] for details.\nExamples\nSee this tutorial.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix: adata.uns['neighbors'] needs to\nbe present.",
            "project_dir Path | strUnion[Path, str]": "Path to directory for exported SPRING files.",
            "embedding_method str": "Name of a 2-D embedding in adata.obsm",
            "subplot_name str | NoneOptional[str] (default: None)": "Name of subplot folder to be created at project_dir+\"/\"+subplot_name",
            "cell_groupings str | Iterable[str] | NoneUnion[str, Iterable[str], None] (default: None)": "Instead of importing all categorical annotations when None,\npass a list of keys for adata.obs.",
            "custom_color_tracks str | Iterable[str] | NoneUnion[str, Iterable[str], None] (default: None)": "Specify specific adata.obs keys for continuous coloring.",
            "total_counts_key str (default: 'n_counts')": "Name of key for total transcript counts in adata.obs.",
            "overwrite bool (default: False)": "When True, existing counts matrices in project_dir are overwritten."
        }
    },
    "https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.exporting.cellbrowser.html": {
        "function_name": "scanpy.external.exporting.cellbrowser(adata, data_dir, data_name, embedding_keys=None, annot_keys=('louvain', 'percent_mito', 'n_genes', 'n_counts'), cluster_field='louvain', nb_marker=50, skip_matrix=False, html_dir=None, port=None, do_debug=False)",
        "description": "Export adata to a UCSC Cell Browser project directory. If html_dir is\nset, subsequently build the html files from the project directory into\nhtml_dir. If port is set, start an HTTP server in the background and\nserve html_dir on port.\nBy default, export all gene expression data from adata.raw, the\nannotations louvain, percent_mito, n_genes and n_counts and the top\nnb_marker cluster markers. All existing files in data_dir are\noverwritten, except cellbrowser.conf.\nSee UCSC Cellbrowser for\ndetails.\nExamples\nSee this\ntutorial.",
        "Parameters": {
            "adata AnnData": "Annotated data matrix",
            "data_dir Path | strUnion[Path, str]": "Path to directory for exported Cell Browser files.\nUsually these are the files exprMatrix.tsv.gz, meta.tsv,\ncoordinate files like tsne.coords.tsv,\nand cluster marker gene lists like markers.tsv.\nA file cellbrowser.conf is also created with pointers to these files.\nAs a result, each adata object should have its own project_dir.",
            "data_name str": "Name of dataset in Cell Browser, a string without special characters.\nThis is written to data_dir/cellbrowser.conf.\nIdeally this is a short unique name for the dataset,\nlike \"pbmc3k\" or \"tabulamuris\".",
            "embedding_keys Iterable[str] | Mapping | str | NoneUnion[Iterable[str], Mapping[str, str], str, None] (default: None)": "2-D embeddings in adata.obsm to export.\nThe prefix X_ or X_draw_graph_ is not necessary.\nCoordinates missing from adata are skipped.\nBy default (or when specifying 'all' or None), these keys are tried:\n[\"tsne\", \"umap\", \"pagaFa\", \"pagaFr\", \"pagaUmap\", \"phate\",\n\"fa\", \"fr\", \"kk\", \"drl\", \"rt\", \"trimap\"].\nFor these, default display labels are automatically used.\nFor other values, you can specify a mapping from coordinate name to\ndisplay label, e.g. {\"tsne\": \"t-SNE by Scanpy\"}.",
            "annot_keys Iterable[str] | Mapping | NoneUnion[Iterable[str], Mapping[str, str], None] (default: ('louvain', 'percent_mito', 'n_genes', 'n_counts'))": "Annotations in adata.obsm to export.\nCan be a mapping from annotation column name to display label.\nSpecify None for all available columns in .obs.",
            "skip_matrix bool (default: False)": "Do not export the matrix.\nIf you had previously exported this adata into the same data_dir,\nthen there is no need to export the whole matrix again.\nThis option will make the export a lot faster,\ne.g. when only coordinates or meta data were changed.",
            "html_dir Path | str | NoneUnion[Path, str, None] (default: None)": "If this variable is set, the export will build html\nfiles from data_dir to html_dir, creating html/js/json files.\nUsually there is one global html output directory for all datasets.\nOften, html_dir is located under a webserver\u2019s (like Apache)\nhtdocs directory or is copied to one.\nA directory html_dir/project_name will be created and\nan index.html will be created under html_dir for all subdirectories.\nExisting files will be overwritten.\nIf do not to use html_dir,\nyou can use the command line tool cbBuild to build the html directory.",
            "port int | NoneOptional[int] (default: None)": "If this variable and html_dir are set,\nPython\u2019s built-in web server will be spawned as a daemon in the\nbackground and serve the files under html_dir.\nTo kill the process, call cellbrowser.cellbrowser.stop().",
            "do_debug bool (default: False)": "Activate debugging output"
        }
    }
}